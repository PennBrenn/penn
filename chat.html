<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Page Pet - Penn</title>
<style>
  /* Minimal, self-contained styles so you can drop this into any site */
  .page-pet {
    position: fixed;
    left: 20px;
    top: calc(100% - 140px); /* initial near bottom */
    width: 96px;
    height: 96px;
    z-index: 999999;
    user-select: none;
    cursor: grab;
    will-change: transform;
    display: inline-block;
    pointer-events: auto;
  }

  .page-pet.dragging { cursor: grabbing; }

  .page-pet img {
    width: 96px;
    height: 96px;
    display: block;
    transform-origin: center center;
    pointer-events: none; /* let parent handle events */
  }

  /* Name tag */
  .pet-name {
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    bottom: 110%;
    background: rgba(0,0,0,0.7);
    color: white;
    padding: 4px 8px;
    border-radius: 8px;
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    font-size: 12px;
    white-space: nowrap;
    opacity: 0;
    transition: opacity 0.12s ease;
    pointer-events: none;
    box-shadow: 0 2px 8px rgba(0,0,0,0.4);
  }

  .pet-show-name .pet-name { opacity: 1; }

  /* CSS keyframes used for subtle visual wiggle when idle; animations themselves are frame-based */
  @keyframes idle-wiggle {
    0% { transform: translateY(0) scale(1); }
    50% { transform: translateY(-2px) scale(1.01); }
    100% { transform: translateY(0) scale(1); }
  }
  .pet-idle img { animation: idle-wiggle 1.4s ease-in-out infinite; }

  /* climbing rotates the sprite slightly to feel like it's on wall */
  .pet-climbing img { transform-origin: 50% 90%; }
  .pet-climbing-left img { transform: rotate(-10deg); }
  .pet-climbing-right img { transform: rotate(10deg); }

  /* subtle transition for position (actual movement uses transform to be smoother) */
  .page-pet { transition: transform 0.06s linear; }

  /* optional: prevent text selection on the page while dragging pet */
  body.pet-dragging { user-select: none; -webkit-user-select: none; -moz-user-select: none; }
</style>
</head>
<body>
<!-- Pet container -->
<div id="pagePet" class="page-pet pet-idle" aria-label="penn" role="img" data-name="penn">
  <div class="pet-name">penn</div>
  <img id="petFrame" src="/animations/walk-right/frame1.png" alt="penn">
</div>

<script>
/*
  Interactive Page Pet
  - Single-file; drop into any site.
  - Expects animations in /animations/<name>/frame{1..6}.png
  - Animation names: walk-left, walk-right, climb-left, climb-right, hang, picked-up, falling
*/

(() => {
  const petRoot = document.getElementById('pagePet');
  const petImg = document.getElementById('petFrame');
  const nameTag = petRoot.querySelector('.pet-name');

  // Config
  const SIZE = 96; // px (frame size)
  const FRAME_COUNT = 6;
  const FRAME_MS = 120; // frame switch interval
  const WALK_SPEED = 110; // px/sec walking
  const FOLLOW_SPEED = 200; // px/sec when actively following mouse
  const GRAVITY = 2000; // px/sec^2
  const FLOOR_MARGIN = 8; // bottom margin
  const MOUSE_FOLLOW_RADIUS = 220; // px for when pet decides to follow
  const WALL_CLIMB_SPEED = 80; // px/sec vertical when climbing
  const HOVER_NAME_DELAY = 1000; // ms to show name on mousedown long-press

  // State
  let state = {
    x: 20,
    y: window.innerHeight - SIZE - FLOOR_MARGIN,
    vx: 0,
    vy: 0,
    targetX: null,
    facing: 'right', // 'left' or 'right'
    mode: 'idle', // 'idle','walk','climb','hang','fall','picked'
    anim: 'walk-right',
    lastTime: performance.now(),
    frameIndex: 1,
    frameTimer: 0,
    dragging: false,
    mouseX: null,
    mouseY: null,
    isMouseInside: false,
    nameTimer: null,
    showName: false
  };

  // Animation folder mapping: for some modes we map to a specific anim folder
  function animForState() {
    switch(state.mode) {
      case 'walk':
        return state.facing === 'left' ? 'walk-left' : 'walk-right';
      case 'climb':
        return state.facing === 'left' ? 'climb-left' : 'climb-right';
      case 'hang':
        return 'hang';
      case 'picked':
        return 'picked-up';
      case 'fall':
        return 'falling';
      default:
        // idle uses walk-right frame but we won't move; choose facing folder to keep visuals consistent
        return state.facing === 'left' ? 'walk-left' : 'walk-right';
    }
  }

  // Utility: clamp
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

  // Set pet CSS transform to state.x/state.y
  function applyTransform() {
    petRoot.style.transform = `translate(${Math.round(state.x)}px, ${Math.round(state.y)}px)`;
  }

  // Change mode helper (adds CSS classes)
  function setMode(newMode) {
    if (state.mode === newMode) return;
    petRoot.classList.remove('pet-idle','pet-climbing','pet-climbing-left','pet-climbing-right','pet-show-name');
    if (newMode === 'idle') petRoot.classList.add('pet-idle');
    if (newMode === 'climb') {
      petRoot.classList.add('pet-climbing');
      if (state.facing === 'left') petRoot.classList.add('pet-climbing-left');
      else petRoot.classList.add('pet-climbing-right');
    }
    if (state.showName) petRoot.classList.add('pet-show-name');
    state.mode = newMode;
    updateAnim(); // pick animation folder
  }

  // Update animation folder and reset frame cycle
  function updateAnim() {
    const newAnim = animForState();
    if (state.anim !== newAnim) {
      state.anim = newAnim;
      state.frameIndex = 1;
      state.frameTimer = 0;
      setFrame(1);
    }
  }

  // Set image src for a specific frame index
  function setFrame(index) {
    // note: avoid caching breakage in dev; in production you can remove timestamp
    const path = `/animations/${state.anim}/frame${index}.png`;
    petImg.src = path;
  }

  // Frame tick (advance frame based on FRAME_MS)
  function frameTick(dt) {
    state.frameTimer += dt;
    if (state.frameTimer >= FRAME_MS) {
      state.frameTimer -= FRAME_MS;
      state.frameIndex++;
      if (state.frameIndex > FRAME_COUNT) state.frameIndex = 1;
      setFrame(state.frameIndex);
    }
  }

  // Decide next random walk target
  function pickRandomTarget() {
    const margin = 40;
    const minX = 0;
    const maxX = Math.max(0, window.innerWidth - SIZE);
    state.targetX = Math.floor(Math.random() * (maxX - minX - margin * 2) + margin);
    if (state.targetX < state.x) state.facing = 'left';
    else state.facing = 'right';
    setMode('walk');
    updateAnim();
  }

  // Physics & movement update
  function update(t) {
    const now = t;
    const dt = Math.min(40, now - state.lastTime); // ms
    state.lastTime = now;
    const secs = dt / 1000;

    // If dragging or picked, physics paused
    if (state.dragging || state.mode === 'picked') {
      // gentle idle when mouse is near and not dragging: maybe hang
      frameTick(dt);
      applyTransform();
      requestAnimationFrame(update);
      return;
    }

    // If pet is following mouse because mouse within radius, move towards mouse
    if (state.mouseX !== null && state.mouseY !== null && state.isMouseInside) {
      const dx = state.mouseX - (state.x + SIZE/2);
      const dy = state.mouseY - (state.y + SIZE/2);
      const dist = Math.hypot(dx, dy);

      if (dist < 20) {
        // near mouse - possibly hang
        setMode('hang');
        state.vx = 0;
      } else {
        // move horizontally toward mouse, while obeying walls and ground
        state.facing = dx < 0 ? 'left' : 'right';
        const desiredSpeed = FOLLOW_SPEED;
        state.vx = clamp((dx / dist) * desiredSpeed, -desiredSpeed, desiredSpeed);
        setMode('walk');
      }
    } else {
      // regular behavior: if currently falling, apply gravity
      if (state.mode === 'fall') {
        // apply gravity
        state.vy += GRAVITY * secs;
        state.y += state.vy * secs;
        // stop when hitting floor
        const floorY = window.innerHeight - SIZE - FLOOR_MARGIN;
        if (state.y >= floorY) {
          state.y = floorY;
          state.vy = 0;
          pickRandomTarget(); // resume walking
        }
        frameTick(dt);
        applyTransform();
        requestAnimationFrame(update);
        return;
      }

      // not following mouse and not falling -> walk around randomly
      if (state.targetX === null) pickRandomTarget();

      const dx = state.targetX - state.x;
      const dir = dx < 0 ? -1 : 1;
      state.facing = dir < 0 ? 'left' : 'right';
      const move = dir * WALK_SPEED * secs;
      if (Math.abs(dx) <= Math.abs(move)) {
        // reached target
        state.x = state.targetX;
        state.targetX = null;
        setMode('idle');
        state.vx = 0;
      } else {
        state.x += move;
      }
    }

    // simple wall detection/climb
    const atLeftWall = state.x <= 0;
    const atRightWall = state.x + SIZE >= window.innerWidth;
    if ((atLeftWall && state.facing === 'left') || (atRightWall && state.facing === 'right')) {
      // start climbing: move up a bit until top or a fixed climb time
      setMode('climb');
      // climb up
      state.y -= WALL_CLIMB_SPEED * secs;
      // ensure we don't climb above top
      state.y = Math.max(0, state.y);
      // after climbing high enough, reverse direction and drop slightly
      const climbedEnough = state.y < window.innerHeight * 0.25; // heuristics
      if (climbedEnough) {
        // reverse
        state.facing = state.facing === 'left' ? 'right' : 'left';
        // walk away from wall a bit
        state.x += (state.facing === 'left' ? -1 : 1) * 20;
        pickRandomTarget();
      }
    }

    // Keep pet within horizontal bounds
    state.x = clamp(state.x, 0, Math.max(0, window.innerWidth - SIZE));

    // If pet walked off a ledge (shouldn't on simple site, but check) -> fall
    const floorY = window.innerHeight - SIZE - FLOOR_MARGIN;
    if (state.y < floorY && state.mode !== 'fall' && state.mode !== 'climb') {
      // start falling
      setMode('fall');
      state.vy = 0;
    }

    // finalize animation tick and transform
    frameTick(dt);
    applyTransform();

    // Occasionally choose new target if idle for long
    if (state.mode === 'idle' && Math.random() < 0.008) pickRandomTarget();

    requestAnimationFrame(update);
  }

  // Start the loop
  state.lastTime = performance.now();
  pickRandomTarget();
  requestAnimationFrame(update);

  // Mouse tracking
  window.addEventListener('mousemove', (ev) => {
    state.mouseX = ev.clientX;
    state.mouseY = ev.clientY;
    state.isMouseInside = true;

    // If mouse within FOLLOW radius horizontally and vertically, set to follow
    const petCenterX = state.x + SIZE/2;
    const petCenterY = state.y + SIZE/2;
    const d = Math.hypot(state.mouseX - petCenterX, state.mouseY - petCenterY);
    if (d <= MOUSE_FOLLOW_RADIUS) {
      // will be handled in update loop; optionally pick more aggressive mode
      setMode('walk');
    }
  });

  window.addEventListener('mouseout', (ev) => {
    // when leaving window, treat as not inside
    state.isMouseInside = false;
    state.mouseX = null;
    state.mouseY = null;
  });

  // Dragging mechanics
  let dragOffsetX = 0;
  let dragOffsetY = 0;
  let longPressTimeout = null;
  let longPressFired = false;

  petRoot.addEventListener('mousedown', (ev) => {
    ev.preventDefault();
    // Start drag
    state.dragging = true;
    longPressFired = false;
    document.body.classList.add('pet-dragging');
    petRoot.classList.add('dragging');
    // compute offset between mouse and pet top-left
    const rect = petRoot.getBoundingClientRect();
    dragOffsetX = ev.clientX - rect.left;
    dragOffsetY = ev.clientY - rect.top;

    // set picked animation
    setMode('picked');
    state.vx = 0;
    state.vy = 0;

    // start name timer (1s) - show name on long-press
    longPressTimeout = setTimeout(() => {
      longPressFired = true;
      state.showName = true;
      petRoot.classList.add('pet-show-name');
    }, HOVER_NAME_DELAY);
  });

  window.addEventListener('mousemove', (ev) => {
    if (!state.dragging) return;
    state.x = ev.clientX - dragOffsetX;
    state.y = ev.clientY - dragOffsetY;
    // keep inside window roughly
    state.x = clamp(state.x, 0, Math.max(0, window.innerWidth - SIZE));
    state.y = clamp(state.y, 0, Math.max(0, window.innerHeight - SIZE));
    applyTransform();
    // update name if immediate hover
  });

  window.addEventListener('mouseup', (ev) => {
    if (!state.dragging) return;
    state.dragging = false;
    document.body.classList.remove('pet-dragging');
    petRoot.classList.remove('dragging');
    // cancel long press timer if didn't fire
    if (longPressTimeout) {
      clearTimeout(longPressTimeout);
      longPressTimeout = null;
    }

    // if long press hadn't fired but mouse is hovering, show name briefly
    if (!longPressFired) {
      state.showName = true;
      petRoot.classList.add('pet-show-name');
      setTimeout(() => {
        state.showName = false;
        petRoot.classList.remove('pet-show-name');
      }, 1400);
    }

    // On release, simulate falling physics from drop point (unless on floor)
    const floorY = window.innerHeight - SIZE - FLOOR_MARGIN;
    if (state.y < floorY - 2) {
      setMode('fall');
      // initial fall velocity inherits small downward push
      state.vy = 30 + Math.random() * 80;
    } else {
      // landed near floor - pick new target after small delay
      pickRandomTarget();
    }
  });

  // Show name on hover quickly
  petRoot.addEventListener('mouseenter', () => {
    state.showName = true;
    petRoot.classList.add('pet-show-name');
  });
  petRoot.addEventListener('mouseleave', () => {
    state.showName = false;
    petRoot.classList.remove('pet-show-name');
  });

  // On touch devices: support touch drag
  petRoot.addEventListener('touchstart', (ev) => {
    ev.preventDefault();
    const t = ev.touches[0];
    state.dragging = true;
    document.body.classList.add('pet-dragging');
    petRoot.classList.add('dragging');
    const rect = petRoot.getBoundingClientRect();
    dragOffsetX = t.clientX - rect.left;
    dragOffsetY = t.clientY - rect.top;
    setMode('picked');
    // long press
    longPressTimeout = setTimeout(() => {
      longPressFired = true;
      state.showName = true;
      petRoot.classList.add('pet-show-name');
    }, HOVER_NAME_DELAY);
  }, {passive:false});

  window.addEventListener('touchmove', (ev) => {
    if (!state.dragging) return;
    const t = ev.touches[0];
    state.x = t.clientX - dragOffsetX;
    state.y = t.clientY - dragOffsetY;
    state.x = clamp(state.x, 0, Math.max(0, window.innerWidth - SIZE));
    state.y = clamp(state.y, 0, Math.max(0, window.innerHeight - SIZE));
    applyTransform();
  }, {passive:false});

  window.addEventListener('touchend', (ev) => {
    if (!state.dragging) return;
    state.dragging = false;
    document.body.classList.remove('pet-dragging');
    petRoot.classList.remove('dragging');
    if (longPressTimeout) {
      clearTimeout(longPressTimeout); longPressTimeout = null;
    }
    if (!longPressFired) {
      state.showName = true;
      petRoot.classList.add('pet-show-name');
      setTimeout(() => {
        state.showName = false;
        petRoot.classList.remove('pet-show-name');
      }, 1200);
    }
    const floorY = window.innerHeight - SIZE - FLOOR_MARGIN;
    if (state.y < floorY - 2) {
      setMode('fall');
      state.vy = 30 + Math.random() * 80;
    } else {
      pickRandomTarget();
    }
  }, {passive:false});

  // Window resize: keep pet on screen
  window.addEventListener('resize', () => {
    state.x = clamp(state.x, 0, Math.max(0, window.innerWidth - SIZE));
    state.y = clamp(state.y, 0, Math.max(0, window.innerHeight - SIZE));
    applyTransform();
  });

  // Safety: if any animation frame not found, fallback to other frames or silent fail
  petImg.addEventListener('error', (e) => {
    // if image missing, try to fallback to the walk-right folder default frame
    if (!petImg.src.includes('/animations/')) return;
    try {
      petImg.src = `/animations/walk-right/frame1.png`;
    } catch (err) {
      // nothing else to do
    }
  });

  // Expose a small API for host page (optional)
  window.__pagePet = {
    setName(name) {
      petRoot.setAttribute('data-name', name);
      nameTag.textContent = name;
    },
    show() { petRoot.style.display = 'inline-block'; },
    hide() { petRoot.style.display = 'none'; },
    goto(x, y) {
      state.x = clamp(x, 0, Math.max(0, window.innerWidth - SIZE));
      state.y = clamp(y, 0, Math.max(0, window.innerHeight - SIZE));
      applyTransform();
    },
    setMode(m) { setMode(m); }
  };

  // initial transform
  applyTransform();

})(); // end IIFE
</script>

<!--
  USAGE:
  - Place sprite folders at /animations/<animation-name>/frame1.png .. frame6.png
  - Supported names: walk-left, walk-right, climb-left, climb-right, hang, picked-up, falling
  - You can call window.__pagePet.setName("newname") to change shown name.
-->
</body>
</html>
