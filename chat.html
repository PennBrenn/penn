<!-- Put this near the end of your <body> -->
<style>
  /* --- Pet container + visuals --- */
  .page-pet {
    position: fixed;
    left: 50px;
    top: calc(100vh - 120px);
    width: 96px;
    height: 96px;
    z-index: 999999;
    pointer-events: auto;
    user-select: none;
    touch-action: none;
  }

  .pet-sprite {
    width: 96px;
    height: 96px;
    background-size: contain;
    background-repeat: no-repeat;
    transform-origin: 50% 80%;
    will-change: transform, top, left;
    position: relative;
    display: block;
  }

  /* small shadow to ground the pet */
  .pet-shadow {
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    bottom: 4px;
    width: 60px;
    height: 10px;
    border-radius: 50%;
    filter: blur(6px);
    background: rgba(0,0,0,0.25);
    transition: transform 0.12s linear, opacity 0.12s linear;
    pointer-events: none;
  }

  /* Name tag shown on hover or long press */
  .pet-name {
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    bottom: 110%;
    background: rgba(0,0,0,0.75);
    color: #fff;
    padding: 4px 8px;
    border-radius: 6px;
    font-family: sans-serif;
    font-size: 12px;
    white-space: nowrap;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.12s ease;
  }

  .pet-visible-name {
    opacity: 1 !important;
  }

  /* CSS keyframe animations used as visual states (not frame swapping) */
  @keyframes pet-bob {
    0% { transform: translateY(0) }
    50% { transform: translateY(-4px) }
    100% { transform: translateY(0) }
  }
  .anim-idle {
    animation: pet-bob 1s ease-in-out infinite;
  }

  @keyframes pet-lean {
    0% { transform: translateY(0) rotate(0deg) }
    50% { transform: translateY(-2px) rotate(-3deg) }
    100% { transform: translateY(0) rotate(0deg) }
  }
  .anim-walk-lean {
    animation: pet-lean 0.45s ease-in-out infinite;
  }

  /* when climbing, tilt slightly */
  .anim-climb {
    animation: pet-lean 0.3s linear infinite;
  }

  /* picked up scale effect */
  .anim-picked {
    transform: scale(1.05);
    transition: transform 0.12s ease;
    filter: drop-shadow(0 6px 8px rgba(0,0,0,0.3));
  }

  /* small responsive tweak */
  @media (max-width: 420px) {
    .page-pet { width: 72px; height: 72px; }
    .pet-sprite { width:72px; height:72px; background-size: contain; }
  }
</style>

<div id="pagePet" class="page-pet" aria-hidden="true">
  <div id="petName" class="pet-name">penn</div>
  <div id="petSprite" class="pet-sprite anim-idle" role="img" aria-label="page pet"></div>
  <div id="petShadow" class="pet-shadow"></div>
</div>

<script>
/*
  Page Pet "penn"
  - Expects animations in /animations/<name>/frame1.png ... frame6.png
  - Animation names supported (as specified): 
    walk-left, walk-right, climb-left, climb-right, hang, picked-up, falling
  - All frames are 96x96
*/

(function () {
  const pet = document.getElementById('pagePet');
  const sprite = document.getElementById('petSprite');
  const nameTag = document.getElementById('petName');
  const shadow = document.getElementById('petShadow');

  // configuration
  const W = 96; // width
  const H = 96; // height (adjust if you use different size)
  const FLOOR_MARGIN = 24; // how far above bottom is considered "on floor"
  const animFrameCount = 6;
  const fps = 10; // frames per second for frame swaps
  const gravity = 1200; // px / s^2
  const frictionX = 0.98;

  // state
  let x = 50, y = window.innerHeight - H - FLOOR_MARGIN; // top-left coords
  let vx = 0, vy = 0;
  let facing = 'right'; // 'left' or 'right'
  let mode = 'idle'; // 'idle','walk','climb','hang','picked','fall'
  let frameIndex = 0;
  let lastFrameTime = 0;
  let lastUpdate = performance.now();
  let isDragging = false;
  let dragOffset = {x:0,y:0};
  let mouse = {x: 0, y: 0, isDown: false};
  let longPressTimer = null;
  let showName = false;
  let randomWalkTimer = 0;
  let targetVX = 0;

  // pre-load image URLs for each animation
  const anims = {
    'walk-left': [],
    'walk-right': [],
    'climb-left': [],
    'climb-right': [],
    'hang': [],
    'picked-up': [],
    'falling': []
  };

  function preload() {
    Object.keys(anims).forEach(name => {
      for (let i=1;i<=animFrameCount;i++) {
        const url = `/animations/${name}/frame${i}.png`;
        anims[name].push(url);
        const img = new Image();
        img.src = url; // browser handles caching/404s
      }
    });
  }
  preload();

  // helpers for animation selection
  function currentAnim() {
    if (isDragging) return 'picked-up';
    if (mode === 'fall') return 'falling';
    if (mode === 'climb') return (facing === 'left') ? 'climb-left' : 'climb-right';
    if (mode === 'hang') return 'hang';
    if (mode === 'walk') return (facing === 'left') ? 'walk-left' : 'walk-right';
    return (facing === 'left') ? 'walk-left' : 'walk-right'; // fallback to a simple walk spritesheet but anim-idle adds bob
  }

  // set sprite frame by background-image
  function setSpriteFrame(animName, idx) {
    const arr = anims[animName];
    if (!arr || arr.length === 0) {
      sprite.style.backgroundImage = '';
      return;
    }
    const url = arr[ idx % arr.length ];
    sprite.style.backgroundImage = `url("${url}")`;
  }

  // show/hide name
  function setNameVisible(v) {
    if (v) nameTag.classList.add('pet-visible-name');
    else nameTag.classList.remove('pet-visible-name');
    showName = v;
  }

  // clamp helpers
  function clamp(n, a, b) { return Math.max(a, Math.min(b, n)); }

  // update loop
  function tick(now) {
    const dt = Math.min(0.05, (now - lastUpdate)/1000); // seconds, cap to avoid huge steps
    lastUpdate = now;

    // handle behavior: if dragging, follow pointer; else physics + AI
    if (isDragging) {
      // follow mouse with offset
      x = mouse.x - dragOffset.x;
      y = mouse.y - dragOffset.y;
      vy = 0;
      vx = 0;
      mode = 'picked';
      facing = (mouse.x < x + W/2) ? 'left' : 'right';
      shadow.style.transform = 'translateY(0) scale(0.9)';
      shadow.style.opacity = '0.7';
    } else {
      // if near mouse and mouse active, try to follow/hang
      const dx = (mouse.x || 0) - (x + W/2);
      const dy = (mouse.y || 0) - (y + H/2);
      const dist = Math.hypot(dx, dy);

      // basic AI: sometimes choose a target vx to random-walk
      randomWalkTimer -= dt;
      if (randomWalkTimer <= 0) {
        randomWalkTimer = 1 + Math.random()*3;
        // choose a new horizontal velocity target
        if (Math.random() < 0.6) {
          targetVX = (Math.random() * 120 - 60); // -60 .. +60 px/s
        } else {
          // stay still sometimes
          targetVX = 0;
        }
      }

      // mouse-follow priority: if mouse within 220px and not too low, approach
      if (mouse.isDown || dist < 180) {
        // attempt to go to mouse x; if mouse is up high, try to climb walls to reach it
        // move horizontally toward mouse
        const desiredVX = clamp(dx * 2, -240, 240); // proportional
        vx += (desiredVX - vx) * clamp(8*dt, 0, 1); // smooth approach

        // if mouse is close horizontally but above and near wall, trigger climb
        if (Math.abs(dx) < 40 && dy < -30 && (x < 30 || x + W > window.innerWidth - 30)) {
          // near left or right wall and target above -> climb
          mode = 'climb';
          vy = -220; // start climbing up
        } else if (dist < 120 && Math.abs(dy) < 40) {
          mode = 'hang';
          vx *= 0.92;
          vy = 0;
        } else {
          // walking / approach
          mode = Math.abs(vx) > 10 ? 'walk' : 'idle';
        }
      } else {
        // no mouse attraction: free walking
        // approach targetVX set by random walker
        vx += (targetVX - vx) * clamp(2*dt, 0, 1);
        mode = Math.abs(vx) > 12 ? 'walk' : 'idle';
      }

      // apply gravity if not on "floor" and not climbing/hang
      const bottomY = window.innerHeight - H - FLOOR_MARGIN;
      if (mode === 'climb') {
        // climbing: reduce gravity influence; allow moving up a bit
        vy += -300 * dt; // upward "climb impulse" while climbing
        // small horizontal friction to hold onto wall
        vx *= 0.85;
      } else if (mode === 'hang') {
        // hang: little gravity and almost stationary
        vy *= 0.95;
        vx *= 0.6;
      } else {
        // normal physics
        vy += gravity * dt;
        vx *= frictionX;
      }

      // integrate
      x += vx * dt;
      y += vy * dt;

      // boundaries: left/right walls => climb/turn around if contacting
      if (x <= 0) {
        x = 0;
        // bounce back a bit and climb
        facing = 'right';
        mode = 'climb';
        vx = Math.abs(vx) * 0.4 + 40;
        vy = -200;
      } else if (x + W >= window.innerWidth) {
        x = window.innerWidth - W;
        facing = 'left';
        mode = 'climb';
        vx = -Math.abs(vx) * 0.4 - 40;
        vy = -200;
      }

      // land on bottom
      if (y >= bottomY) {
        // landed
        y = bottomY;
        vy = 0;
        // small bounce if falling
        if (mode === 'fall' || Math.abs(vy) > 300) {
          // landing bounce visual
          shadow.style.transform = 'translateY(0) scale(1.1)';
          setTimeout(()=>{ shadow.style.transform = 'translateY(0) scale(0.9)'; }, 80);
        }
        // decide walking or idle
        mode = Math.abs(vx) > 20 ? 'walk' : 'idle';
      } else {
        // in-air
        if (!isDragging) mode = 'fall';
      }

      // small floor friction
      if (y === bottomY) vx *= 0.999;

      // update shadow scale based on height
      const heightAboveFloor = bottomY - y; // 0..big
      const s = clamp(1 - heightAboveFloor/300, 0.5, 1.15);
      shadow.style.transform = `translateY(0) scale(${s})`;
      shadow.style.opacity = clamp(1 - heightAboveFloor/400, 0.2, 0.95);
    }

    // facing: if vx significant, update facing
    if (Math.abs(vx) > 10) {
      facing = vx > 0 ? 'right' : 'left';
    } else if (mouse.isDown && mouse.x < x + W/2) {
      facing = 'left';
    }

    // clamp position inside window
    x = clamp(x, 0, Math.max(0, window.innerWidth - W));
    y = clamp(y, -H*2, window.innerHeight - H); // allow climbing above screen a bit

    // place on screen
    pet.style.transform = `translate(${Math.round(x)}px, ${Math.round(y)}px)`;

    // sprite frame update
    if (now - lastFrameTime > (1000 / fps)) {
      lastFrameTime = now;
      frameIndex = (frameIndex + 1) % animFrameCount;
      const animName = currentAnim();
      setSpriteFrame(animName, frameIndex);
      // small class toggles for CSS animations
      sprite.classList.toggle('anim-walk-lean', mode === 'walk');
      sprite.classList.toggle('anim-climb', mode === 'climb');
      sprite.classList.toggle('anim-idle', mode === 'idle');
      sprite.classList.toggle('anim-picked', isDragging || mode === 'picked');
    }

    // continue loop
    requestAnimationFrame(tick);
  }

  // start loop
  lastUpdate = performance.now();
  requestAnimationFrame(tick);

  // Mouse & touch handlers for dragging + long press name reveal
  function onPointerDown(e) {
    e.preventDefault();
    const clientX = (e.touches ? e.touches[0].clientX : e.clientX);
    const clientY = (e.touches ? e.touches[0].clientY : e.clientY);

    // are we clicking inside the pet bounds?
    const boundsLeft = x;
    const boundsTop = y;
    const boundsRight = x + W;
    const boundsBottom = y + H;

    if (clientX >= boundsLeft && clientX <= boundsRight && clientY >= boundsTop && clientY <= boundsBottom) {
      isDragging = true;
      dragOffset.x = clientX - x;
      dragOffset.y = clientY - y;
      mouse.isDown = true;
      // start long press timer to show name
      longPressTimer = setTimeout(()=> setNameVisible(true), 900);
      // also show immediately on hover style after 200ms if hover desired
      // mark pointer capture for touch
      try { (e.target || e.srcElement).setPointerCapture && (e.target || e.srcElement).setPointerCapture(e.pointerId); } catch (err) {}
    } else {
      mouse.isDown = true;
      // if pointer down elsewhere, still set long press to maybe call pet
      longPressTimer = setTimeout(()=> setNameVisible(true), 1100);
    }
  }

  function onPointerMove(e) {
    const clientX = (e.touches ? e.touches[0].clientX : e.clientX);
    const clientY = (e.touches ? e.touches[0].clientY : e.clientY);
    mouse.x = clientX;
    mouse.y = clientY;
    // if dragging, position will be set in tick
  }

  function onPointerUp(e) {
    // release drag
    mouse.isDown = false;
    if (longPressTimer) { clearTimeout(longPressTimer); longPressTimer = null; }
    // hide name unless hovering
    setTimeout(()=> setNameVisible(false), 350);

    if (isDragging) {
      // throw physics: give initial velocities based on pointer movement (approx)
      // We'll attempt to approximate throw by checking last movement
      // For simplicity, set vx by delta between mouse and center
      const centerX = x + W/2;
      const deltaX = (mouse.x || centerX) - centerX;
      vx = clamp(deltaX * 6, -600, 600);
      vy = -120 + Math.random()*40; // small upward toss
      isDragging = false;
      mode = 'fall';
    }
  }

  // show name on hover for pointerenter, hide on leave
  pet.addEventListener('mouseenter', () => setNameVisible(true));
  pet.addEventListener('mouseleave', () => { if (!mouse.isDown) setNameVisible(false); });

  // attach pointer events (works for touch and mouse)
  window.addEventListener('pointerdown', onPointerDown, {passive:false});
  window.addEventListener('pointermove', onPointerMove, {passive:true});
  window.addEventListener('pointerup', onPointerUp, {passive:true});
  // for touchfallback
  window.addEventListener('touchstart', onPointerDown, {passive:false});
  window.addEventListener('touchmove', onPointerMove, {passive:true});
  window.addEventListener('touchend', onPointerUp, {passive:true});

  // track mouse position for non-touch
  window.addEventListener('mousemove', function(e){
    mouse.x = e.clientX;
    mouse.y = e.clientY;
  });

  // window resize: keep pet on screen
  window.addEventListener('resize', () => {
    x = clamp(x, 0, Math.max(0, window.innerWidth - W));
    y = clamp(y, -H*2, window.innerHeight - H);
  });

  // show name on quick hover / mousedown for 1s (handled by timers above)
  // initial sprite
  setSpriteFrame(currentAnim(), 0);

  // Expose a small API on window for integration if desired
  window.pagePet = {
    element: pet,
    setPosition(px, py) { x = px; y = py; },
    getPosition() { return {x,y}; },
    setName(n) { nameTag.textContent = n; },
    playAnim(name) { mode = name; }, // naive
    show() { pet.style.display = ''; },
    hide() { pet.style.display = 'none'; }
  };

})();
</script>
