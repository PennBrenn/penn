<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Galactic Navigator - Interstellar Sentient AI</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Courier+Prime:wght@400;700&display=swap');

        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            overflow: hidden;
            background: #000000;
            font-family: 'Courier Prime', 'Courier New', monospace;
            color: #FFFFFF;
            cursor: crosshair;
        }

        canvas { display: block; }

        #ui-overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
        }

        #telemetry {
            position: absolute;
            top: 20px; right: 20px;
            width: 380px;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border: 2px solid #FFFFFF;
            pointer-events: none;
        }

        .telem-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
            font-size: 13px;
            border-bottom: 1px solid #333;
            padding-bottom: 3px;
        }

        .telem-label { color: #888; font-weight: bold; }
        .telem-value { color: #FFF; text-align: right; }
        .telem-warning { color: #FF4444; }
        .telem-success { color: #00FF00; }

        #autopilot-log {
            position: absolute;
            bottom: 80px; left: 20px;
            width: 500px; height: 150px;
            overflow: hidden;
            display: flex;
            flex-direction: column-reverse;
            font-size: 11px;
            color: #AAA;
            background: linear-gradient(0deg, rgba(0,0,0,0.95) 0%, rgba(0,0,0,0) 100%);
            padding-left: 10px;
            border-left: 2px solid #444;
        }

        .log-entry {
            margin-top: 2px;
            text-shadow: 1px 1px 2px #000;
        }

        #progress-bar-container {
            position: absolute;
            bottom: 20px; left: 50%;
            transform: translateX(-50%);
            width: 600px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #FFFFFF;
            padding: 12px;
        }

        #progress-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
            font-size: 12px;
        }

        #progress-bar-bg {
            width: 100%;
            height: 20px;
            background: #222;
            border: 1px solid #666;
            position: relative;
            overflow: hidden;
        }

        #progress-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #00FFFF, #00FF00);
            width: 0%;
            transition: width 0.3s ease;
        }

        #context-indicator {
            position: absolute;
            top: 20px; left: 20px;
            font-size: 24px;
            font-weight: bold;
            color: #00FFFF;
            text-shadow: 0 0 10px #00FFFF;
            pointer-events: none;
        }

        #click-hint {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 14px;
            color: #666;
            pointer-events: none;
            opacity: 0;
            animation: fadeInOut 3s ease-in-out infinite;
        }

        @keyframes fadeInOut {
            0%, 100% { opacity: 0; }
            50% { opacity: 0.6; }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div id="ui-overlay">
        <div id="context-indicator">GALACTIC</div>
        
        <div id="telemetry">
            <div class="telem-row"><span class="telem-label">VELOCITY</span><span class="telem-value" id="val-vel">0 m/s</span></div>
            <div class="telem-row"><span class="telem-label">ALTITUDE</span><span class="telem-value" id="val-alt">0 km</span></div>
            <div class="telem-row"><span class="telem-label">ESCAPE VEL</span><span class="telem-value" id="val-esc">0 m/s</span></div>
            <div class="telem-row"><span class="telem-label">G-LOAD</span><span class="telem-value" id="val-g">0.0 G</span></div>
            <div class="telem-row"><span class="telem-label">THROTTLE</span><span class="telem-value" id="val-throttle">0%</span></div>
            <div class="telem-row"><span class="telem-label">AI STATE</span><span class="telem-value" id="val-state">IDLE</span></div>
            <div class="telem-row"><span class="telem-label">TARGET</span><span class="telem-value" id="val-target">NONE</span></div>
            <div class="telem-row"><span class="telem-label">SYSTEM</span><span class="telem-value" id="val-system">ALPHA</span></div>
            <div class="telem-row"><span class="telem-label">ETA</span><span class="telem-value" id="val-eta">--</span></div>
            <div class="telem-row"><span class="telem-label">FLAGS</span><span class="telem-value" id="val-flags">0</span></div>
        </div>

        <div id="autopilot-log"></div>

        <div id="progress-bar-container">
            <div id="progress-info">
                <span id="progress-phase">IDLE</span>
                <span id="progress-eta">ETA: --</span>
            </div>
            <div id="progress-bar-bg">
                <div id="progress-bar-fill"></div>
            </div>
        </div>

        <div id="click-hint">CLICK ANY PLANET TO OVERRIDE TARGET</div>
    </div>

    <script>
        'use strict';

        // ========== CONSTANTS ==========
        const G = 1200;
        const PHYSICS_HZ = 600;
        const DT = 1 / PHYSICS_HZ;
        
        const SHIP_THRUST_MAX = 12000;
        const SHIP_MASS = 10;
        const SHIP_ROT_TORQUE = 1.5;
        const SHIP_ROT_DAMPING = 0.90;
        const SHIP_ACCEL_RAMP = 0.06;
        
        const SYSTEM_SEPARATION = 250000; // Vast void between systems
        const INTERSTELLAR_MAX_SPEED = 8000; // High speed in void
        const CRUISING_SPEED = 2500; // Normal max speed
        
        const MIN_LANDING_MASS = 1500;
        const ORBIT_DURATION_MIN = 8.0;
        const SURFACE_PAUSE_MIN = 5.0;
        const SURFACE_PAUSE_MAX = 10.0;
        const PREDICTION_TIME = 10.0;
        const PREDICTION_STEPS = 100;

        // ========== MATH UTILITIES ==========
        class Vec2 {
            constructor(x, y) { this.x = x; this.y = y; }
            add(v) { return new Vec2(this.x + v.x, this.y + v.y); }
            sub(v) { return new Vec2(this.x - v.x, this.y - v.y); }
            mult(s) { return new Vec2(this.x * s, this.y * s); }
            div(s) { return new Vec2(this.x / s, this.y / s); }
            mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
            magSq() { return this.x * this.x + this.y * this.y; }
            norm() { const m = this.mag(); return m === 0 ? new Vec2(0, 0) : this.div(m); }
            dist(v) { return this.sub(v).mag(); }
            dot(v) { return this.x * v.x + this.y * v.y; }
            cross(v) { return this.x * v.y - this.y * v.x; }
            perp() { return new Vec2(-this.y, this.x); }
            copy() { return new Vec2(this.x, this.y); }
            angle() { return Math.atan2(this.y, this.x); }
            rotate(a) {
                const c = Math.cos(a), s = Math.sin(a);
                return new Vec2(this.x * c - this.y * s, this.x * s + this.y * c);
            }
        }

        function normalizeAngle(a) {
            a = a % (2 * Math.PI);
            if (a > Math.PI) a -= 2 * Math.PI;
            if (a < -Math.PI) a += 2 * Math.PI;
            return a;
        }

        function formatTime(seconds) {
            if (!isFinite(seconds) || seconds < 0) return '--';
            if (seconds < 60) return `${seconds.toFixed(0)}s`;
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}m ${secs}s`;
        }

        // ========== GLOBALS ==========
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        let width, height;

        let bodies = [], particles = [], asteroids = [];
        let systems = []; // Array of star systems
        let ship;
        let camScale = 0.001;
        let targetCamScale = 0.001;
        let logBuffer = [];
        let simTime = 0;
        let worldCamPos = new Vec2(0, 0);
        let mouseWorldPos = new Vec2(0, 0);

        // ========== BODY CLASS ==========
        class Body {
            constructor(x, y, mass, radius, isStatic = false, name = "Body", system = null) {
                this.pos = new Vec2(x, y);
                this.vel = new Vec2(0, 0);
                this.acc = new Vec2(0, 0);
                this.mass = mass;
                this.radius = radius;
                this.isStatic = isStatic;
                this.name = name;
                this.system = system;
                this.path = [];
                this.angle = 0;
                this.parent = null;
                this.color = '#FFFFFF';
                this.isStar = false;
                this.isAsteroid = false;
                this.isPlanet = false;
                this.vertices = [];
                
                if (!isStatic && mass > 50 && !this.isAsteroid) {
                    const steps = radius > 150 ? 180 : 60;
                    const seed = Math.random() * 100;
                    for (let i = 0; i < steps; i++) {
                        const a = (i / steps) * Math.PI * 2;
                        let r = radius;
                        r += Math.sin(a * (5 + Math.random()*5) + seed) * (radius * 0.02);
                        r += Math.sin(a * (10 + Math.random()*10) + seed*2) * (radius * 0.01);
                        if (Math.sin(a * 3 + seed) > 0.8) r += Math.random() * (radius * 0.05);
                        r += (Math.random()-0.5) * (radius * 0.005);
                        this.vertices.push(new Vec2(Math.cos(a) * r, Math.sin(a) * r));
                    }
                }
            }

            updatePhysics(dt) {
                if (this.isStatic) return;
                this.vel = this.vel.add(this.acc.mult(dt));
                this.pos = this.pos.add(this.vel.mult(dt));
                this.acc = new Vec2(0, 0);
                
                if (simTime % 1.0 < dt && !this.isAsteroid) {
                    this.path.push(this.pos.copy());
                    if (this.path.length > 800) this.path.shift();
                }
            }

            draw(ctx, zoom) {
                // Orbit trail
                if (this.path.length > 2 && zoom < 0.5 && !this.isAsteroid) {
                    ctx.beginPath();
                    ctx.strokeStyle = '#222222';
                    ctx.lineWidth = 1 / zoom;
                    ctx.moveTo(this.path[0].x, this.path[0].y);
                    for (let i = 2; i < this.path.length; i += 2) {
                        ctx.lineTo(this.path[i].x, this.path[i].y);
                    }
                    ctx.stroke();
                }

                ctx.save();
                ctx.translate(this.pos.x, this.pos.y);
                ctx.rotate(this.angle);

                ctx.strokeStyle = this.color;
                ctx.lineWidth = this.isAsteroid ? 0.5 / zoom : (this.isStar ? 2 / zoom : 1.5 / zoom);
                ctx.fillStyle = this.isStar ? '#FFFFFF' : '#000000';
                
                ctx.beginPath();
                if (this.vertices.length > 0) {
                    ctx.moveTo(this.vertices[0].x, this.vertices[0].y);
                    for (let i = 1; i < this.vertices.length; i++) {
                        ctx.lineTo(this.vertices[i].x, this.vertices[i].y);
                    }
                    ctx.closePath();
                } else {
                    ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                }
                ctx.fill();
                ctx.stroke();
                
                // Star glow
                if (this.isStar && zoom > 0.001) {
                    const gradient = ctx.createRadialGradient(0, 0, this.radius, 0, 0, this.radius * 2);
                    gradient.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
                    gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius * 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Name
                if ((this.mass > 200 || this.isStar) && !this.isAsteroid && zoom > 0.01) {
                    ctx.fillStyle = this.isStar ? '#FFFFFF' : '#888888';
                    ctx.font = `${Math.max(10, 14/zoom)}px monospace`;
                    ctx.fillText(this.name, this.radius * 1.3, 0);
                }

                ctx.restore();
            }
        }

        // ========== SHIP CLASS ==========
        class Ship extends Body {
            constructor(x, y) {
                super(x, y, SHIP_MASS, 10, false, "NAVIGATOR");
                this.angle = -Math.PI / 2;
                this.angularVel = 0;
                this.mode = "IDLE";
                this.target = null;
                this.targetBlacklist = null; // Blacklist during landing
                this.currentSystem = null;
                this.pid = { kp: 5.0, kd: 12.0, prevErr: 0 };
                this.trail = [];
                this.decisionTimer = 0;
                this.orbitTimer = 0;
                this.surfacePauseDuration = 0;
                this.currentG = 0;
                this.throttle = 0;
                this.targetThrottle = 0;
                this.gravVector = new Vec2(0, 0);
                this.aiCmdVector = new Vec2(0, 0);
                this.predictedPath = [];
                this.dominantBody = null;
                this.deployedFlags = [];
                this.visitedBodies = new Set();
                this.clearanceVector = null;
                this.isInterstellar = false;
                this.interstellarPhase = null; // ESCAPE, ISM, APPROACH
                this.eta = null;
                this.journeyStartDist = null;
            }

            log(msg) {
                logBuffer.unshift(`[${this.mode}] ${msg}`);
                if (logBuffer.length > 14) logBuffer.pop();
                const logEl = document.getElementById('autopilot-log');
                logEl.innerHTML = logBuffer.map(l => `<div class="log-entry">${l}</div>`).join('');
            }

            findDominantBody() {
                let maxInfluence = 0;
                let dominant = null;
                
                // Check all stars first
                for (let sys of systems) {
                    const star = sys.star;
                    const dist = this.pos.dist(star.pos);
                    const influence = star.mass / (dist * dist);
                    if (influence > maxInfluence) {
                        maxInfluence = influence;
                        dominant = star;
                    }
                }
                
                // Check planets in current system
                if (this.currentSystem) {
                    for (let b of bodies) {
                        if (b === this || b.isStatic || b.isAsteroid || b.system !== this.currentSystem) continue;
                        const dist = this.pos.dist(b.pos);
                        const influence = b.mass / (dist * dist);
                        if (influence > maxInfluence) {
                            maxInfluence = influence;
                            dominant = b;
                        }
                    }
                }
                
                return dominant;
            }

            calculateSOI(body) {
                if (!body.parent) return body.mass * 8.0;
                const parentDist = body.pos.dist(body.parent.pos);
                return parentDist * Math.pow(body.mass / body.parent.mass, 0.4);
            }

            predictPath() {
                this.predictedPath = [];
                
                let simPos = this.pos.copy();
                let simVel = this.vel.copy();
                const dt = PREDICTION_TIME / PREDICTION_STEPS;
                
                for (let i = 0; i < PREDICTION_STEPS; i++) {
                    let acc = new Vec2(0, 0);
                    
                    // Gravity from all significant bodies
                    for (let b of bodies) {
                        if (b === this || b.isAsteroid) continue;
                        const r = b.pos.sub(simPos);
                        const dSq = r.magSq();
                        if (dSq > 1) {
                            acc = acc.add(r.norm().mult(G * b.mass / dSq));
                        }
                    }
                    
                    simVel = simVel.add(acc.mult(dt));
                    simPos = simPos.add(simVel.mult(dt));
                    this.predictedPath.push(simPos.copy());
                }
            }

            // Clearance Vector - navigate around dense asteroid clusters
            calculateClearanceVector() {
                this.clearanceVector = null;
                
                if (!this.target) return;
                
                const toTarget = this.target.pos.sub(this.pos);
                const targetDist = toTarget.mag();
                
                // Check asteroids along path
                let closestObstacle = null;
                let closestDist = Infinity;
                
                for (let ast of asteroids) {
                    // Only check asteroids in current system
                    if (ast.system !== this.currentSystem) continue;
                    
                    const toAst = ast.pos.sub(this.pos);
                    const astDist = toAst.mag();
                    
                    // Is asteroid in our path?
                    const projection = toAst.dot(toTarget.norm());
                    if (projection > 0 && projection < targetDist) {
                        const perpDist = Math.abs(toAst.cross(toTarget.norm()) / toTarget.mag());
                        
                        if (perpDist < 300 && astDist < closestDist) {
                            closestDist = astDist;
                            closestObstacle = ast;
                        }
                    }
                }
                
                if (closestObstacle) {
                    // Calculate tangent to go around obstacle
                    const toObs = closestObstacle.pos.sub(this.pos);
                    const perpDir = toObs.perp().norm();
                    
                    // Choose direction more aligned with velocity
                    const align1 = perpDir.dot(this.vel.norm());
                    const align2 = perpDir.mult(-1).dot(this.vel.norm());
                    
                    this.clearanceVector = align1 > align2 ? perpDir : perpDir.mult(-1);
                    
                    return closestObstacle;
                }
                
                return null;
            }

            updateLogic(dt) {
                this.decisionTimer += dt;
                
                // Determine current system
                let minDistToStar = Infinity;
                for (let sys of systems) {
                    const dist = this.pos.dist(sys.star.pos);
                    if (dist < minDistToStar) {
                        minDistToStar = dist;
                        this.currentSystem = sys.name;
                    }
                }
                
                this.dominantBody = this.findDominantBody();
                
                if (Math.floor(simTime * 10) % 5 === 0) {
                    this.predictPath();
                }
                
                // Check if target is in different system
                if (this.target && this.target.system !== this.currentSystem) {
                    this.isInterstellar = true;
                } else {
                    this.isInterstellar = false;
                }
                
                // Calculate ETA
                if (this.target) {
                    const dist = this.pos.dist(this.target.pos);
                    const relVel = this.vel.sub(this.target.vel).mag();
                    this.eta = relVel > 10 ? dist / relVel : null;
                    
                    if (!this.journeyStartDist) this.journeyStartDist = dist;
                } else {
                    this.eta = null;
                    this.journeyStartDist = null;
                }

                if (!this.target && this.mode === "IDLE" && this.decisionTimer > 2.0) {
                    this.pickNewTarget();
                }

                if (!this.target && this.mode !== "PANIC") return;

                let vectorCmd = new Vec2(0, 0);
                const target = this.target;
                
                // ===== INTERSTELLAR LOGIC =====
                if (this.isInterstellar) {
                    const currentStar = systems.find(s => s.name === this.currentSystem).star;
                    const targetStar = systems.find(s => s.name === target.system).star;
                    
                    const distToCurrentStar = this.pos.dist(currentStar.pos);
                    const distToTargetStar = this.pos.dist(targetStar.pos);
                    const currentSOI = this.calculateSOI(currentStar);
                    const targetSOI = this.calculateSOI(targetStar);
                    
                    // Phase 1: ESCAPE current system
                    if (distToCurrentStar < currentSOI * 2) {
                        this.interstellarPhase = "ESCAPE";
                        this.mode = "INTERSTELLAR";
                        
                        const escapeDir = this.pos.sub(currentStar.pos).norm();
                        vectorCmd = escapeDir.mult(SHIP_THRUST_MAX);
                        
                        if (this.decisionTimer > 1.0) {
                            this.log(`Escaping ${this.currentSystem} system`);
                            this.decisionTimer = 0;
                        }
                    }
                    // Phase 2: ISM (Interstellar Medium) - high speed cruise
                    else if (distToTargetStar > targetSOI * 2) {
                        this.interstellarPhase = "ISM";
                        this.mode = "INTERSTELLAR";
                        
                        const toTargetStar = targetStar.pos.sub(this.pos);
                        const dist = toTargetStar.mag();
                        const halfway = dist / 2;
                        
                        // High speed until halfway, then decelerate
                        if (distToTargetStar > halfway) {
                            // Accelerate to high speed
                            const desiredVel = toTargetStar.norm().mult(INTERSTELLAR_MAX_SPEED);
                            vectorCmd = desiredVel.sub(this.vel).mult(2.0);
                        } else {
                            // Decelerate to cruising speed
                            const currentSpeed = this.vel.mag();
                            if (currentSpeed > CRUISING_SPEED) {
                                vectorCmd = this.vel.norm().mult(-SHIP_THRUST_MAX * 0.8);
                            }
                        }
                        
                        if (this.decisionTimer > 3.0) {
                            this.log(`ISM transit to ${target.system}`);
                            this.decisionTimer = 0;
                        }
                    }
                    // Phase 3: APPROACH target system
                    else {
                        this.interstellarPhase = "APPROACH";
                        this.mode = "INTERSTELLAR";
                        
                        const toTargetStar = targetStar.pos.sub(this.pos);
                        const desiredVel = toTargetStar.norm().mult(CRUISING_SPEED);
                        vectorCmd = desiredVel.sub(this.vel).mult(3.0);
                        
                        // Enter target system
                        if (distToTargetStar < targetSOI * 0.5) {
                            this.isInterstellar = false;
                            this.mode = "TRANSFER";
                            this.log(`Entered ${target.system} SOI`);
                        }
                    }
                }
                // ===== LOCAL SYSTEM LOGIC =====
                else {
                    const rVec = this.pos.sub(target.pos);
                    const vVec = this.vel.sub(target.vel);
                    const dist = rVec.mag();
                    const speed = vVec.mag();
                    const mu = G * target.mass;
                    
                    const h = rVec.cross(vVec);
                    const en = (speed*speed)/2 - mu/dist;
                    const a = -mu / (2*en);
                    const eVec = rVec.mult(speed*speed - mu/dist).sub(vVec.mult(rVec.dot(vVec))).div(mu);
                    const ecc = eVec.mag();
                    const peDist = a * (1 - ecc);
                    const SOI = this.calculateSOI(target);
                    
                    const escapeVel = Math.sqrt(2 * mu / dist);

                    // Clearance Vector for asteroid navigation
                    if (this.mode === "TRANSFER" || this.mode === "INSERTION") {
                        const obstacle = this.calculateClearanceVector();
                        if (obstacle && this.clearanceVector) {
                            // Throttle down and navigate to gap
                            vectorCmd = this.clearanceVector.mult(SHIP_THRUST_MAX * 0.5);
                            
                            if (this.decisionTimer > 0.8) {
                                this.log("Clearance: navigating asteroid gap");
                                this.decisionTimer = 0;
                            }
                        }
                    }

                    switch (this.mode) {
                        case "IDLE":
                            if (!this.target) this.pickNewTarget();
                            else {
                                this.mode = "TRANSFER";
                                this.decisionTimer = 0;
                            }
                            break;

                        case "TRANSFER":
                            if (dist < SOI) {
                                this.mode = "INSERTION";
                                this.decisionTimer = 0;
                                this.log(`SOI entry: ${target.name}`);
                                break;
                            }
                            
                            // If no clearance issue, normal intercept
                            if (!this.clearanceVector) {
                                const toTarget = target.pos.sub(this.pos);
                                const interceptSpeed = Math.min(CRUISING_SPEED, dist * 0.05 + 500);
                                const desiredVel = toTarget.norm().mult(interceptSpeed);
                                vectorCmd = vectorCmd.add(desiredVel.sub(vVec).mult(2.5));
                            }
                            break;

                        case "INSERTION":
                            const rDotV = rVec.dot(vVec);
                            
                            if ((rDotV >= 0 && dist < peDist + 300) || dist < peDist + 150) {
                                if (speed > escapeVel || ecc > 0.8) {
                                    vectorCmd = vectorCmd.add(vVec.norm().mult(-SHIP_THRUST_MAX));
                                } else if (ecc > 0.15) {
                                    vectorCmd = vectorCmd.add(vVec.norm().mult(-SHIP_THRUST_MAX * 0.6));
                                } else {
                                    this.mode = "ORBIT";
                                    this.orbitTimer = 0;
                                    this.log("Orbit achieved");
                                }
                            } else {
                                if (peDist < target.radius + 100) {
                                    vectorCmd = vectorCmd.add(rVec.norm().mult(SHIP_THRUST_MAX * 0.5));
                                }
                            }
                            
                            if (dist > SOI && rDotV > 0) {
                                this.mode = "TRANSFER";
                                this.log("Escaped SOI - retry");
                            }
                            break;

                        case "ORBIT":
                            this.orbitTimer += dt;
                            
                            const vCircular = Math.sqrt(mu / dist);
                            const orbitalDir = (h >= 0) ? 1 : -1;
                            const tangentDir = rVec.perp().norm().mult(orbitalDir);
                            const desiredOrbVel = tangentDir.mult(vCircular);
                            
                            vectorCmd = vectorCmd.add(desiredOrbVel.sub(vVec).mult(2.0));
                            
                            if (this.orbitTimer > ORBIT_DURATION_MIN) {
                                if (target.mass >= MIN_LANDING_MASS) {
                                    this.mode = "LANDING";
                                    this.targetBlacklist = target; // BLACKLIST target
                                    this.decisionTimer = 0;
                                    this.log("Landing sequence");
                                } else {
                                    this.log(`${target.name} too small`);
                                    this.visitedBodies.add(target.name);
                                    this.pickNewTarget();
                                }
                            }
                            break;

                        case "LANDING":
                            const altitude = dist - target.radius - this.radius;
                            const gravity = mu / (dist * dist);
                            const maxDecel = (SHIP_THRUST_MAX / SHIP_MASS) - gravity;
                            
                            const radialVel = vVec.dot(rVec.norm());
                            const tangentialVelVec = vVec.sub(rVec.norm().mult(radialVel));
                            
                            if (tangentialVelVec.mag() > 3.0) {
                                vectorCmd = vectorCmd.add(tangentialVelVec.mult(-10.0));
                            }
                            
                            if (altitude < 800) {
                                const targetSinkRate = -Math.max(3.0, altitude * 0.08);
                                const sinkError = targetSinkRate - radialVel;
                                const hoverThrust = gravity * SHIP_MASS;
                                const verticalCmd = rVec.norm().mult(hoverThrust + sinkError * 150);
                                vectorCmd = vectorCmd.add(verticalCmd);
                            } else {
                                if (radialVel > -50) {
                                    vectorCmd = vectorCmd.add(rVec.norm().mult(-SHIP_THRUST_MAX * 0.3));
                                }
                                
                                if (radialVel < 0) {
                                    const stoppingDist = (radialVel * radialVel) / (2 * Math.max(1, maxDecel));
                                    if (altitude < stoppingDist * 1.3) {
                                        const brakeStrength = Math.min(1.0, (stoppingDist * 1.3) / altitude);
                                        vectorCmd = vectorCmd.add(rVec.norm().mult(SHIP_THRUST_MAX * brakeStrength));
                                    }
                                }
                            }
                            
                            if (altitude < 8.0 && vVec.mag() < 60) {
                                this.mode = "SURFACE";
                                this.targetBlacklist = null; // Clear blacklist
                                this.decisionTimer = 0;
                                this.surfacePauseDuration = SURFACE_PAUSE_MIN + Math.random() * (SURFACE_PAUSE_MAX - SURFACE_PAUSE_MIN);
                                this.log(`Touchdown: ${target.name}`);
                                
                                this.deployedFlags.push({
                                    pos: this.pos.copy(),
                                    body: target,
                                    time: simTime
                                });
                                this.visitedBodies.add(target.name);
                            }
                            break;

                        case "SURFACE":
                            vectorCmd = new Vec2(0, 0);
                            this.targetThrottle = 0;
                            
                            if (this.decisionTimer > this.surfacePauseDuration) {
                                this.mode = "TAKEOFF";
                                this.log("Launch");
                            }
                            break;

                        case "TAKEOFF":
                            vectorCmd = rVec.norm().mult(SHIP_THRUST_MAX);
                            if (dist > target.radius * 2.5) {
                                this.pickNewTarget();
                                this.mode = "TRANSFER";
                                this.journeyStartDist = null;
                            }
                            break;
                    }
                }

                // ===== SMOOTH ROTATION & THRUST =====
                this.aiCmdVector = vectorCmd.copy();
                const cmdMag = vectorCmd.mag();
                const cmdDir = cmdMag > 0.1 ? vectorCmd.norm() : new Vec2(Math.cos(this.angle), Math.sin(this.angle));
                
                let desiredAngle = cmdDir.angle();
                
                // Lead rotation - start turning before burn
                const angleErr = normalizeAngle(desiredAngle - this.angle);
                const angleDeriv = angleErr - this.pid.prevErr;
                this.pid.prevErr = angleErr;
                
                const rotTorque = angleErr * this.pid.kp + angleDeriv * this.pid.kd;
                this.angularVel += rotTorque * SHIP_ROT_TORQUE * dt;
                this.angularVel *= SHIP_ROT_DAMPING;
                this.angle += this.angularVel * dt;
                
                const facing = new Vec2(Math.cos(this.angle), Math.sin(this.angle));
                const alignment = facing.dot(cmdDir);
                
                let thrustPct = 0;
                if ((alignment > 0.7 || (this.mode === "LANDING" && alignment > 0.4)) && cmdMag > 1.0) {
                    thrustPct = Math.min(1.0, cmdMag / SHIP_THRUST_MAX);
                }
                
                // Gradual throttle
                this.targetThrottle = thrustPct;
                const throttleDiff = this.targetThrottle - this.throttle;
                this.throttle += throttleDiff * SHIP_ACCEL_RAMP;
                
                if (this.throttle > 0.01) {
                    const actualThrust = this.throttle * SHIP_THRUST_MAX;
                    this.acc = this.acc.add(facing.mult(actualThrust));
                    this.currentG = actualThrust / 9.81;
                    
                    // Exhaust
                    for (let i = 0; i < 3; i++) {
                        const spread = (Math.random() - 0.5) * 0.5;
                        const pVel = this.vel.add(facing.mult(-700 * this.throttle)).add(facing.perp().mult(spread * 180));
                        const pPos = this.pos.add(facing.mult(-20));
                        particles.push(new Particle(pPos, pVel));
                    }
                }
                
                // PERSISTENT TRAIL (10,000+ steps)
                if (simTime % 0.02 < dt) {
                    this.trail.push(this.pos.copy());
                    if (this.trail.length > 12000) this.trail.shift();
                }
            }

            pickNewTarget() {
                // Prefer targets in different systems for variety
                const allCandidates = bodies.filter(b => 
                    b.mass >= MIN_LANDING_MASS && 
                    !b.isStar &&
                    b !== this.target &&
                    !this.visitedBodies.has(b.name) &&
                    !b.isAsteroid
                );
                
                if (allCandidates.length === 0) {
                    this.visitedBodies.clear();
                    this.log("All bodies visited - reset");
                }
                
                const candidates = allCandidates.length > 0 ? allCandidates : 
                    bodies.filter(b => b.mass >= MIN_LANDING_MASS && !b.isStar && !b.isAsteroid);
                
                if (candidates.length > 0) {
                    // Occasionally pick interstellar target
                    const interstellarChance = Math.random() > 0.6;
                    let chosen;
                    
                    if (interstellarChance) {
                        const otherSystems = candidates.filter(c => c.system !== this.currentSystem);
                        if (otherSystems.length > 0) {
                            chosen = otherSystems[Math.floor(Math.random() * otherSystems.length)];
                        } else {
                            chosen = candidates[Math.floor(Math.random() * candidates.length)];
                        }
                    } else {
                        chosen = candidates[Math.floor(Math.random() * candidates.length)];
                    }
                    
                    this.target = chosen;
                    this.mode = "TRANSFER";
                    this.decisionTimer = 0;
                    this.journeyStartDist = this.pos.dist(chosen.pos);
                    this.log(`Target: ${chosen.name} [${chosen.system}]`);
                }
            }

            draw(ctx, zoom) {
                // Flags
                for (let flag of this.deployedFlags) {
                    if (!flag.body) continue;
                    const flagWorldPos = flag.body.pos.add(flag.pos.sub(flag.body.pos));
                    
                    // Only render if in view
                    const distToCam = flagWorldPos.dist(worldCamPos);
                    if (distToCam > 100000 / zoom) continue;
                    
                    ctx.save();
                    ctx.translate(flagWorldPos.x, flagWorldPos.y);
                    ctx.strokeStyle = '#FFFFFF';
                    ctx.lineWidth = 1 / zoom;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(0, -30 / zoom);
                    ctx.stroke();
                    ctx.fillStyle = '#00FF00';
                    ctx.beginPath();
                    ctx.moveTo(0, -30 / zoom);
                    ctx.lineTo(15 / zoom, -25 / zoom);
                    ctx.lineTo(0, -20 / zoom);
                    ctx.fill();
                    ctx.restore();
                }
                
                // Predicted 10s path (dotted)
                if (this.predictedPath.length > 1 && this.mode !== "SURFACE") {
                    ctx.save();
                    ctx.strokeStyle = '#FFFF00';
                    ctx.lineWidth = 1.5 / zoom;
                    ctx.setLineDash([8 / zoom, 8 / zoom]);
                    ctx.beginPath();
                    ctx.moveTo(this.pos.x, this.pos.y);
                    for (let i = 0; i < this.predictedPath.length; i += 3) {
                        ctx.lineTo(this.predictedPath[i].x, this.predictedPath[i].y);
                    }
                    ctx.stroke();
                    ctx.setLineDash([]);
                    ctx.restore();
                }
                
                // PERSISTENT TRAIL (10,000+ points)
                if (this.trail.length > 1) {
                    ctx.save();
                    ctx.lineWidth = 2 / zoom;
                    
                    const step = Math.max(1, Math.floor(this.trail.length / 1000));
                    
                    for (let i = 0; i < this.trail.length - step; i += step) {
                        const alpha = 0.1 + (i / this.trail.length) * 0.9;
                        ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
                        ctx.beginPath();
                        ctx.moveTo(this.trail[i].x, this.trail[i].y);
                        ctx.lineTo(this.trail[i + step].x, this.trail[i + step].y);
                        ctx.stroke();
                    }
                    ctx.restore();
                }

                // Ship
                ctx.save();
                ctx.translate(this.pos.x, this.pos.y);
                ctx.rotate(this.angle);
                
                ctx.fillStyle = '#000000';
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 2 / zoom;
                
                ctx.beginPath();
                ctx.moveTo(15, 0);
                ctx.lineTo(-10, 10);
                ctx.lineTo(-5, 0);
                ctx.lineTo(-10, -10);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                // Engine glow
                if (this.throttle > 0) {
                    ctx.fillStyle = `rgba(255, 255, 255, ${this.throttle})`;
                    ctx.beginPath();
                    ctx.moveTo(-5, 0);
                    ctx.lineTo(-15 - Math.random() * 10 * this.throttle, 5);
                    ctx.lineTo(-15 - Math.random() * 10 * this.throttle, -5);
                    ctx.fill();
                }
                
                ctx.restore();
            }
        }

        // ========== PARTICLE CLASS ==========
        class Particle {
            constructor(pos, vel) {
                this.pos = pos;
                this.vel = vel;
                this.life = 0.5 + Math.random() * 0.5;
            }
            update(dt) {
                this.pos = this.pos.add(this.vel.mult(dt));
                this.life -= dt;
            }
            draw(ctx, zoom) {
                ctx.fillStyle = `rgba(255, 255, 255, ${this.life})`;
                const s = Math.max(1, 3 / zoom);
                ctx.fillRect(this.pos.x, this.pos.y, s, s);
            }
        }

        // ========== GALAXY GENERATION ==========
        function generateGalaxy() {
            bodies = [];
            asteroids = [];
            systems = [];
            particles = [];
            
            const systemNames = ["ALPHA", "BETA", "GAMMA"];
            const systemPositions = [
                new Vec2(0, 0),
                new Vec2(SYSTEM_SEPARATION, SYSTEM_SEPARATION * 0.3),
                new Vec2(-SYSTEM_SEPARATION * 0.7, SYSTEM_SEPARATION * 0.8)
            ];
            
            for (let sysIdx = 0; sysIdx < 3; sysIdx++) {
                const sysName = systemNames[sysIdx];
                const sysPos = systemPositions[sysIdx];
                
                // Create star
                const starMass = 10000000;
                const starRadius = 1200;
                const star = new Body(sysPos.x, sysPos.y, starMass, starRadius, true, sysName + "-SOL", sysName);
                star.isStar = true;
                star.color = '#FFFFFF';
                bodies.push(star);
                
                systems.push({ name: sysName, star: star, bodies: [] });
                
                // Generate planets
                let dist = 12000;
                const numPlanets = sysIdx === 0 ? 6 : 4 + Math.floor(Math.random() * 3);
                
                for (let i = 0; i < numPlanets; i++) {
                    dist += 12000 + Math.random() * 8000;
                    const angle = Math.random() * Math.PI * 2;
                    const mass = 200000 + Math.random() * 300000;
                    const radius = 400 + Math.sqrt(mass) * 0.5;
                    const ecc = Math.random() * 0.2;
                    
                    const rPeri = dist;
                    const sma = rPeri / (1 - ecc);
                    const vMag = Math.sqrt(G * starMass * (1+ecc) / (sma * (1-ecc)));
                    
                    const planet = new Body(
                        sysPos.x + Math.cos(angle) * dist,
                        sysPos.y + Math.sin(angle) * dist,
                        mass, radius, false,
                        `${sysName}-${i+1}`,
                        sysName
                    );
                    planet.vel = new Vec2(-Math.sin(angle), Math.cos(angle)).mult(vMag);
                    planet.parent = star;
                    planet.isPlanet = true;
                    bodies.push(planet);
                    systems[sysIdx].bodies.push(planet);
                    
                    // Moons
                    if (Math.random() > 0.5) {
                        const numMoons = 1 + Math.floor(Math.random() * 2);
                        for (let m = 0; m < numMoons; m++) {
                            const mDist = radius + 250 + m * 200;
                            const mAng = Math.random() * Math.PI * 2;
                            const mMass = 500 + Math.random() * 1500;
                            const mRad = 30 + Math.sqrt(mMass) * 0.4;
                            
                            const moon = new Body(
                                planet.pos.x + Math.cos(mAng) * mDist,
                                planet.pos.y + Math.sin(mAng) * mDist,
                                mMass, mRad, false,
                                `${planet.name}-M${m+1}`,
                                sysName
                            );
                            const vOrb = Math.sqrt(G * planet.mass / mDist);
                            moon.vel = planet.vel.add(new Vec2(-Math.sin(mAng), Math.cos(mAng)).mult(vOrb));
                            moon.parent = planet;
                            bodies.push(moon);
                            systems[sysIdx].bodies.push(moon);
                        }
                    }
                }
                
                // ALPHA system gets asteroid belt
                if (sysIdx === 0) {
                    const beltRadius = dist * 0.6;
                    const beltWidth = 3000;
                    const numAsteroids = 150;
                    
                    for (let i = 0; i < numAsteroids; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const radius = beltRadius + (Math.random() - 0.5) * beltWidth;
                        
                        const asteroid = new Body(
                            sysPos.x + Math.cos(angle) * radius,
                            sysPos.y + Math.sin(angle) * radius,
                            10 + Math.random() * 40,
                            8 + Math.random() * 15,
                            false,
                            `AST-${i}`,
                            sysName
                        );
                        
                        const vOrb = Math.sqrt(G * starMass / radius) * (0.9 + Math.random() * 0.2);
                        asteroid.vel = new Vec2(-Math.sin(angle), Math.cos(angle)).mult(vOrb);
                        asteroid.parent = star;
                        asteroid.isAsteroid = true;
                        asteroid.color = '#666666';
                        
                        bodies.push(asteroid);
                        asteroids.push(asteroid);
                    }
                }
            }
            
            // Spawn ship in ALPHA system
            const alphaStar = systems[0].star;
            const startPlanet = systems[0].bodies.find(b => b.isPlanet);
            
            if (startPlanet) {
                const startDist = startPlanet.radius + 400;
                ship = new Ship(startPlanet.pos.x + startDist, startPlanet.pos.y);
                const vShipOrb = Math.sqrt(G * startPlanet.mass / startDist);
                ship.vel = startPlanet.vel.add(new Vec2(0, vShipOrb));
                ship.currentSystem = "ALPHA";
                bodies.push(ship);
            }
        }

        // ========== PHYSICS ==========
        function physicsStep() {
            const dt = DT;
            
            for (let i = 0; i < bodies.length; i++) {
                const b1 = bodies[i];
                if (b1.isStatic) continue;
                
                for (let j = 0; j < bodies.length; j++) {
                    if (i === j) continue;
                    const b2 = bodies[j];
                    const rVec = b2.pos.sub(b1.pos);
                    const dSq = rVec.magSq();
                    
                    if (dSq < 1) continue;
                    const dist = Math.sqrt(dSq);
                    
                    // Gravity
                    if (dist > 10) {
                        const f = (G * b2.mass) / dSq;
                        const gForce = rVec.norm().mult(f);
                        b1.acc = b1.acc.add(gForce);
                        if (b1 === ship) ship.gravVector = ship.gravVector.add(gForce);
                    }
                    
                    // Collision
                    if (dist < b1.radius + b2.radius) {
                        if (b1 === ship || b2 === ship) {
                            const theShip = b1 === ship ? b1 : b2;
                            const theBody = b1 === ship ? b2 : b1;
                            
                            // BLACKLIST CHECK - ignore target during landing
                            if (theBody === ship.targetBlacklist) continue;
                            
                            const vRel = theShip.vel.sub(theBody.vel).mag();
                            const normal = theShip.pos.sub(theBody.pos).norm();
                            
                            if (vRel > 120 && !theBody.isAsteroid) {
                                // Crash
                                ship.log("COLLISION - RESTARTING");
                                setTimeout(() => generateGalaxy(), 500);
                                return;
                            } else {
                                theShip.pos = theBody.pos.add(normal.mult(theShip.radius + theBody.radius + 0.1));
                                
                                if (theBody.mass >= MIN_LANDING_MASS && !theBody.isAsteroid) {
                                    theShip.vel = theBody.vel.copy();
                                    
                                    if (ship.mode === "LANDING" || ship.mode === "TRANSFER") {
                                        ship.mode = "SURFACE";
                                        ship.targetBlacklist = null;
                                        ship.decisionTimer = 0;
                                        ship.surfacePauseDuration = SURFACE_PAUSE_MIN + Math.random() * (SURFACE_PAUSE_MAX - SURFACE_PAUSE_MIN);
                                        ship.target = theBody;
                                        
                                        ship.deployedFlags.push({
                                            pos: ship.pos.copy(),
                                            body: theBody,
                                            time: simTime
                                        });
                                        ship.visitedBodies.add(theBody.name);
                                        ship.log(`Landed: ${theBody.name}`);
                                    }
                                } else {
                                    // Bounce
                                    const bounceVel = normal.mult(vRel * 0.5);
                                    theShip.vel = theBody.vel.add(bounceVel);
                                }
                            }
                        }
                    }
                }
            }
            
            if (ship) ship.updateLogic(dt);
            for (let b of bodies) b.updatePhysics(dt);
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update(dt);
                if (particles[i].life <= 0) particles.splice(i, 1);
            }
            
            // Floating origin
            if (ship) {
                const shift = ship.pos.copy();
                worldCamPos = worldCamPos.add(shift);
                
                for (let b of bodies) b.pos = b.pos.sub(shift);
                for (let p of particles) p.pos = p.pos.sub(shift);
                for (let b of bodies) {
                    for (let t = 0; t < b.path.length; t++) b.path[t] = b.path[t].sub(shift);
                }
                if (ship.trail) {
                    for (let t = 0; t < ship.trail.length; t++) ship.trail[t] = ship.trail[t].sub(shift);
                }
                
                ship.gravVector = new Vec2(0, 0);
            }
        }

        // ========== RENDERING ==========
        function determineContext() {
            if (!ship) return "GALACTIC";
            
            if (ship.mode === "INTERSTELLAR") return "GALACTIC";
            if (ship.mode === "SURFACE") return "LANDING";
            if (ship.mode === "LANDING") return "LANDING";
            
            const dominant = ship.dominantBody;
            if (!dominant) return "GALACTIC";
            
            const dist = ship.pos.dist(dominant.pos);
            
            if (dominant.isStar) {
                if (dist < 30000) return "SYSTEM";
                return "GALACTIC";
            } else {
                if (dist < dominant.radius * 5) return "LANDING";
                if (dist < 15000) return "SOI";
                return "SYSTEM";
            }
        }

        function draw() {
            if (width !== window.innerWidth || height !== window.innerHeight) {
                width = window.innerWidth;
                height = window.innerHeight;
                canvas.width = width;
                canvas.height = height;
            }
            
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, width, height);
            
            // Autonomous cinematic zoom
            const context = determineContext();
            document.getElementById('context-indicator').textContent = context;
            
            switch (context) {
                case "GALACTIC":
                    targetCamScale = 0.001;
                    break;
                case "SYSTEM":
                    targetCamScale = 0.05;
                    break;
                case "SOI":
                    targetCamScale = 0.3;
                    break;
                case "LANDING":
                    if (ship && ship.target) {
                        const alt = ship.pos.dist(ship.target.pos) - ship.target.radius;
                        targetCamScale = Math.min(2.0, 1.0 / Math.max(0.5, alt / 500));
                    } else {
                        targetCamScale = 1.0;
                    }
                    break;
            }
            
            camScale += (targetCamScale - camScale) * 0.08;
            
            // Powers of Ten Grid
            ctx.save();
            ctx.translate(width/2, height/2);
            ctx.scale(camScale, camScale);
            
            const viewW = width / camScale;
            const viewH = height / camScale;
            
            const gridLevels = [
                { size: 100, minZoom: 0.5, maxZoom: 10, color: '#2A2A2A' },
                { size: 1000, minZoom: 0.05, maxZoom: 1.0, color: '#252525' },
                { size: 10000, minZoom: 0.005, maxZoom: 0.2, color: '#202020' },
                { size: 100000, minZoom: 0.0005, maxZoom: 0.02, color: '#1A1A1A' },
                { size: 1000000, minZoom: 0.00005, maxZoom: 0.002, color: '#151515' }
            ];
            
            for (const level of gridLevels) {
                if (camScale < level.minZoom || camScale > level.maxZoom) continue;
                
                const zoomRange = level.maxZoom - level.minZoom;
                const zoomPos = (camScale - level.minZoom) / zoomRange;
                let alpha = 1.0;
                if (zoomPos < 0.2) alpha = zoomPos / 0.2;
                if (zoomPos > 0.8) alpha = (1.0 - zoomPos) / 0.2;
                alpha = Math.max(0.05, Math.min(1.0, alpha));
                
                const gridSize = level.size;
                const startX = Math.floor((worldCamPos.x - viewW/2) / gridSize) * gridSize;
                const endX = Math.floor((worldCamPos.x + viewW/2) / gridSize) * gridSize;
                const startY = Math.floor((worldCamPos.y - viewH/2) / gridSize) * gridSize;
                const endY = Math.floor((worldCamPos.y + viewH/2) / gridSize) * gridSize;
                
                const r = parseInt(level.color.slice(1, 3), 16);
                const g = parseInt(level.color.slice(3, 5), 16);
                const b = parseInt(level.color.slice(5, 7), 16);
                ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
                ctx.lineWidth = 1.0 / camScale;
                
                ctx.beginPath();
                for (let gx = startX; gx <= endX; gx += gridSize) {
                    const dx = gx - worldCamPos.x;
                    ctx.moveTo(dx, -viewH);
                    ctx.lineTo(dx, viewH);
                }
                for (let gy = startY; gy <= endY; gy += gridSize) {
                    const dy = gy - worldCamPos.y;
                    ctx.moveTo(-viewW, dy);
                    ctx.lineTo(viewW, dy);
                }
                ctx.stroke();
            }
            
            ctx.restore();
            
            // Draw bodies
            ctx.save();
            ctx.translate(width/2, height/2);
            ctx.scale(camScale, camScale);
            
            // Optimize asteroid rendering - only draw close ones
            const asteroidRenderDist = 50000 / camScale;
            
            for (let b of bodies) {
                if (b.isAsteroid) {
                    const dist = b.pos.dist(worldCamPos);
                    if (dist > asteroidRenderDist) continue;
                }
                
                // Draw osculating orbits
                if (b.parent && !b.isStatic && !b.isAsteroid && camScale > 0.01) {
                    const r = b.pos.sub(b.parent.pos);
                    const v = b.vel.sub(b.parent.vel);
                    const mu = G * b.parent.mass;
                    const en = v.magSq()/2 - mu/r.mag();
                    const a = -mu / (2*en);
                    const eVec = r.mult(v.magSq() - mu/r.mag()).sub(v.mult(r.dot(v))).div(mu);
                    const ecc = eVec.mag();
                    
                    if (ecc < 1 && a > 0 && a < 100000) {
                        ctx.save();
                        ctx.translate(b.parent.pos.x, b.parent.pos.y);
                        const angle = Math.atan2(eVec.y, eVec.x);
                        ctx.rotate(angle);
                        
                        ctx.beginPath();
                        ctx.strokeStyle = '#333333';
                        ctx.lineWidth = 1/camScale;
                        ctx.ellipse(-a*ecc, 0, a, a * Math.sqrt(1 - ecc*ecc), 0, 0, 2*Math.PI);
                        ctx.stroke();
                        ctx.restore();
                    }
                }
                
                b.draw(ctx, camScale);
            }
            
            for (let p of particles) p.draw(ctx, camScale);
            
            // Ship's current orbit (ellipse/hyperbola)
            if (ship && ship.dominantBody && ship.mode !== "SURFACE") {
                const dominant = ship.dominantBody;
                const r = ship.pos.sub(dominant.pos);
                const v = ship.vel.sub(dominant.vel);
                const dist = r.mag();
                const speed = v.mag();
                const mu = G * dominant.mass;
                const en = speed * speed / 2 - mu / dist;
                const a = -mu / (2 * en);
                const eVec = r.mult(speed * speed - mu / dist).sub(v.mult(r.dot(v))).div(mu);
                const e = eVec.mag();
                
                const escapeVelocity = Math.sqrt(2 * mu / dist);
                const isEscaping = speed > escapeVelocity;
                
                ctx.save();
                ctx.translate(dominant.pos.x, dominant.pos.y);
                ctx.beginPath();
                ctx.strokeStyle = isEscaping ? '#FF4444' : '#00FFFF';
                ctx.lineWidth = Math.max(1.0, 2.0 / camScale);
                
                if (!isEscaping && e < 1 && a > 0) {
                    // Ellipse
                    ctx.rotate(eVec.angle());
                    ctx.ellipse(-a * e, 0, a, a * Math.sqrt(1 - e * e), 0, 0, 2 * Math.PI);
                    ctx.stroke();
                } else if (isEscaping && e >= 1) {
                    // Hyperbola
                    const angle = eVec.angle();
                    ctx.rotate(angle);
                    const p = Math.abs(a * (1 - e * e));
                    const limit = Math.min(Math.acos(-1 / e) - 0.1, Math.PI * 0.9);
                    
                    ctx.beginPath();
                    for (let th = -limit; th <= limit; th += 0.05) {
                        const rDist = p / (1 + e * Math.cos(th));
                        if (rDist > 0 && rDist < 500000) {
                            const px = rDist * Math.cos(th);
                            const py = rDist * Math.sin(th);
                            if (th === -limit) ctx.moveTo(px, py);
                            else ctx.lineTo(px, py);
                        }
                    }
                    ctx.stroke();
                }
                ctx.restore();
            }
            
            ctx.restore();
            
            // UI Updates
            if (ship) {
                const t = ship.target;
                const dominant = ship.dominantBody;
                const relVel = t ? ship.vel.sub(t.vel).mag() : ship.vel.mag();
                const alt = t ? ship.pos.dist(t.pos) - t.radius : (dominant ? ship.pos.dist(dominant.pos) - dominant.radius : 0);
                
                const escapeVel = dominant ? Math.sqrt(2 * G * dominant.mass / ship.pos.dist(dominant.pos)) : 0;
                
                document.getElementById('val-vel').textContent = relVel.toFixed(0) + " m/s";
                document.getElementById('val-alt').textContent = (alt / 1000).toFixed(1) + " km";
                document.getElementById('val-esc').textContent = escapeVel.toFixed(0) + " m/s";
                document.getElementById('val-g').textContent = ship.currentG.toFixed(2) + " G";
                document.getElementById('val-throttle').textContent = Math.round(ship.throttle * 100) + "%";
                document.getElementById('val-state').textContent = ship.mode;
                document.getElementById('val-target').textContent = t ? t.name : "NONE";
                document.getElementById('val-system').textContent = ship.currentSystem || "VOID";
                document.getElementById('val-flags').textContent = ship.deployedFlags.length;
                
                // ETA
                const etaEl = document.getElementById('val-eta');
                if (ship.eta) {
                    etaEl.textContent = formatTime(ship.eta);
                    etaEl.classList.remove('telem-warning');
                    etaEl.classList.add('telem-success');
                } else {
                    etaEl.textContent = '--';
                    etaEl.classList.remove('telem-success');
                }
                
                // Progress bar
                document.getElementById('progress-phase').textContent = ship.mode;
                document.getElementById('progress-eta').textContent = `ETA: ${formatTime(ship.eta)}`;
                
                if (ship.target && ship.journeyStartDist) {
                    const currentDist = ship.pos.dist(ship.target.pos);
                    const progress = Math.max(0, Math.min(100, (1 - currentDist / ship.journeyStartDist) * 100));
                    document.getElementById('progress-bar-fill').style.width = progress + '%';
                } else {
                    document.getElementById('progress-bar-fill').style.width = '0%';
                }
            }
            
            requestAnimationFrame(draw);
        }

        // ========== INPUT ==========
        canvas.addEventListener('mousedown', (e) => {
            if (!ship) return;
            
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;
            
            // Convert to world coordinates
            const worldX = (mx - width/2) / camScale + worldCamPos.x;
            const worldY = (my - height/2) / camScale + worldCamPos.y;
            mouseWorldPos = new Vec2(worldX, worldY);
            
            // Find clicked body
            let clickedBody = null;
            let minDist = Infinity;
            
            for (let b of bodies) {
                if (b === ship || b.isAsteroid || b.isStar) continue;
                const dist = mouseWorldPos.dist(b.pos);
                if (dist < b.radius && dist < minDist) {
                    minDist = dist;
                    clickedBody = b;
                }
            }
            
            if (clickedBody) {
                ship.target = clickedBody;
                ship.mode = "TRANSFER";
                ship.decisionTimer = 0;
                ship.journeyStartDist = ship.pos.dist(clickedBody.pos);
                ship.visitedBodies.delete(clickedBody.name); // Allow revisit
                ship.log(`OVERRIDE: ${clickedBody.name} [${clickedBody.system}]`);
            }
        });

        // ========== INIT ==========
        generateGalaxy();
        
        setInterval(() => {
            simTime += DT * 10;
            for (let i = 0; i < 10; i++) physicsStep();
        }, 1000 / 60);
        
        requestAnimationFrame(draw);
    </script>
</body>
</html>
