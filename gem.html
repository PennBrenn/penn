<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Penn the Page Pet</title>
    
    <style>
        /* --- PET STYLES (Unchanged) --- */
        #penn-pet-container {
            position: fixed;
            z-index: 9999;
            width: 96px;
            height: 96px;
            pointer-events: auto;
            user-select: none;
            touch-action: none;
            cursor: grab;
        }

        #penn-pet-container.grabbing {
            cursor: grabbing;
        }

        #penn-pet-img {
            width: 100%;
            height: 100%;
            display: block;
            image-rendering: pixelated;
        }

        #penn-name {
            position: absolute;
            top: -30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-family: sans-serif;
            font-size: 12px;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            white-space: nowrap;
        }

        #penn-pet-container:hover #penn-name {
            opacity: 1;
        }
    </style>
</head>
<body>

<script>
    class PagePet {
        constructor() {
            // Configuration
            this.petName = "Penn";
            this.frameRate = 150; 
            this.walkSpeed = 3;
            this.climbSpeed = 2;
            this.gravity = 0.8;
            this.bounce = 0.4; 
            
            // Animation States
            this.states = {
                IDLE: 'idle',
                WALK_LEFT: 'walk left',
                WALK_RIGHT: 'walk right',
                CLIMB_LEFT: 'climb left',
                CLIMB_RIGHT: 'climb right',
                // HANG: 'hang',  <-- REMOVED
                PICKED_UP: 'picked up',
                FALLING: 'falling'
            };

            // Initial State
            this.currentState = this.states.FALLING;
            this.currentFrame = 1;
            this.totalFrames = 6;
            this.animPaused = false; /* UPDATED: Track if animation should freeze */
            
            // Position & Physics
            this.x = window.innerWidth / 2;
            this.y = 0; 
            this.vx = 0; 
            this.vy = 0; 
            
            // Interaction Flags
            this.isDragging = false;
            this.mouseX = 0;
            this.mouseY = 0;
            this.dragOffsetX = 0;
            this.dragOffsetY = 0;

            // DOM Setup
            this.createDOM();
            this.bindEvents();

            // Start Loops
            this.animLoop = setInterval(() => this.updateAnimation(), this.frameRate);
            this.gameLoop = requestAnimationFrame(() => this.updatePhysics());
        }

        createDOM() {
            this.container = document.createElement('div');
            this.container.id = 'penn-pet-container';
            
            this.img = document.createElement('img');
            this.img.id = 'penn-pet-img';
            this.img.draggable = false; 
            
            this.nameTag = document.createElement('div');
            this.nameTag.id = 'penn-name';
            this.nameTag.innerText = this.petName;

            this.container.appendChild(this.nameTag);
            this.container.appendChild(this.img);
            document.body.appendChild(this.container);
        }

        bindEvents() {
            window.addEventListener('mousemove', (e) => {
                this.mouseX = e.clientX;
                this.mouseY = e.clientY;
                if(this.currentState === this.states.IDLE) {
                    this.decideNextMove();
                }
            });

            this.container.addEventListener('mousedown', (e) => {
                this.isDragging = true;
                this.currentState = this.states.PICKED_UP;
                this.animPaused = false; /* UPDATED: Unpause on grab */
                this.container.classList.add('grabbing');
                
                this.dragOffsetX = e.clientX - this.x;
                this.dragOffsetY = e.clientY - this.y;
                this.vx = 0;
                this.vy = 0;
            });

            window.addEventListener('mouseup', () => {
                if (this.isDragging) {
                    this.isDragging = false;
                    this.currentState = this.states.FALLING;
                    this.animPaused = false; /* UPDATED: Unpause on release */
                    this.container.classList.remove('grabbing');
                }
            });
        }

        // --- VISUALS ---
        
        updateAnimation() {
            /* UPDATED: If paused, do not increment frames, just exit */
            if (this.animPaused) return;

            this.currentFrame++;
            if (this.currentFrame > this.totalFrames) this.currentFrame = 1;

            const path = `animations/${this.currentState}/frame${this.currentFrame}.png`;
            this.img.src = path;
        }

        // --- LOGIC & PHYSICS ---

        updatePhysics() {
            const floor = window.innerHeight - 96; 
            const rightWall = window.innerWidth - 96;

            if (this.isDragging) {
                this.x = this.mouseX - this.dragOffsetX;
                this.y = this.mouseY - this.dragOffsetY;
            } 
            else {
                // 1. FALLING
                if (this.currentState === this.states.FALLING) {
                    this.vy += this.gravity;
                    this.y += this.vy;
                    this.x += this.vx;

                    if (this.y >= floor) {
                        this.y = floor;
                        this.vy = -this.vy * this.bounce; 
                        
                        if (Math.abs(this.vy) < 1) {
                            this.vy = 0;
                            this.currentState = this.states.IDLE;
                            setTimeout(() => this.decideNextMove(), 1000);
                        }
                    }
                }

                // 2. WALKING
                else if (this.currentState === this.states.WALK_LEFT) {
                    this.x -= this.walkSpeed;
                    if (this.x <= 0) {
                        this.x = 0;
                        this.currentState = this.states.CLIMB_LEFT; 
                    }
                }
                else if (this.currentState === this.states.WALK_RIGHT) {
                    this.x += this.walkSpeed;
                    if (this.x >= rightWall) {
                        this.x = rightWall;
                        this.currentState = this.states.CLIMB_RIGHT; 
                    }
                }

                // 3. CLIMBING (UPDATED LOGIC)
                else if (this.currentState === this.states.CLIMB_LEFT || this.currentState === this.states.CLIMB_RIGHT) {
                    let isMoving = false;

                    // Try to align with mouse height
                    if (this.y > this.mouseY + 10) {
                        this.y -= this.climbSpeed;
                        isMoving = true;
                    } else if (this.y < this.mouseY - 10) {
                        this.y += this.climbSpeed;
                        isMoving = true;
                    }

                    // UPDATED: If we are moving, play animation. If not, pause animation.
                    this.animPaused = !isMoving; 

                    // Ceiling Hit
                    if (this.y <= 0) {
                        this.y = 0;
                        this.animPaused = false; // Reset pause
                        this.currentState = this.states.FALLING;
                    }
                    // Floor Hit
                    if (this.y >= floor) {
                        this.y = floor;
                        this.animPaused = false; // Reset pause
                        this.currentState = this.states.IDLE;
                    }
                    
                    // Fall off wall if mouse moves too far horizontally
                    // (Optional: keeps him from climbing invisible air if mouse moves to center)
                    if (this.currentState === this.states.CLIMB_LEFT && this.mouseX > 200) {
                         this.animPaused = false;
                         this.currentState = this.states.FALLING;
                    }
                    if (this.currentState === this.states.CLIMB_RIGHT && this.mouseX < rightWall - 200) {
                         this.animPaused = false;
                         this.currentState = this.states.FALLING;
                    }
                }

                // 4. IDLE
                else if (this.currentState === this.states.IDLE) {
                    // Waiting for AI decision
                }
            }

            // Boundary Checks
            if (this.x < 0) this.x = 0;
            if (this.x > rightWall) this.x = rightWall;
            if (this.y > floor) this.y = floor; 

            // Render
            this.container.style.left = `${this.x}px`;
            this.container.style.top = `${this.y}px`;

            requestAnimationFrame(() => this.updatePhysics());
        }

        decideNextMove() {
            if (this.isDragging || this.currentState === this.states.FALLING) return;
            
            // Ensure animation isn't paused if we start walking
            this.animPaused = false; 

            const rand = Math.random();
            const distToMouse = this.mouseX - this.x;

            if (this.y >= window.innerHeight - 100) {
                if (rand < 0.4) {
                    this.currentState = distToMouse < 0 ? this.states.WALK_LEFT : this.states.WALK_RIGHT;
                } else if (rand < 0.8) {
                    this.currentState = Math.random() > 0.5 ? this.states.WALK_LEFT : this.states.WALK_RIGHT;
                } else {
                    this.currentState = this.states.IDLE;
                }
                setTimeout(() => this.decideNextMove(), 2000 + Math.random() * 2000);
            }
        }
    }

    window.addEventListener('load', () => {
        new PagePet();
    });

</script>
</body>
</html>
