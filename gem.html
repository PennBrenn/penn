<div id="penn-pet-container">
    <div id="penn-name">Penn</div>
    <div id="penn-sprite"></div>
</div>

<style>
    /* --- CORE STYLES --- */
    #penn-pet-container {
        position: fixed;
        z-index: 9999;
        width: 96px;
        height: 96px;
        pointer-events: none; /* Let clicks pass through, JS handles pet clicks */
        /* Initial Position */
        left: 50%;
        bottom: 0;
        transform: translate(-50%, 0);
    }

    #penn-sprite {
        width: 100%;
        height: 100%;
        pointer-events: auto; /* Re-enable clicks on the pet itself */
        cursor: grab;
        background-repeat: no-repeat;
        background-size: contain;
        /* Default placeholder if images are missing */
        background-color: transparent; 
    }

    #penn-sprite:active {
        cursor: grabbing;
    }

    /* --- NAME TAG --- */
    #penn-name {
        position: absolute;
        top: -30px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 4px 8px;
        border-radius: 4px;
        font-family: sans-serif;
        font-size: 12px;
        opacity: 0;
        transition: opacity 0.3s ease;
        pointer-events: none;
        white-space: nowrap;
    }

    /* Show name on hover or long press (handled via class) */
    #penn-sprite:hover + #penn-name,
    #penn-pet-container.show-name #penn-name {
        opacity: 1;
        transition-delay: 1s; /* The 1-second delay requirement */
    }

    /* --- ANIMATION CLASSES --- */
    /* These trigger the keyframes generated by JS */
    .anim-walk-left { animation: walk-left 0.8s infinite step-start; }
    .anim-walk-right { animation: walk-right 0.8s infinite step-start; }
    .anim-climb-left { animation: climb-left 0.8s infinite step-start; }
    .anim-climb-right { animation: climb-right 0.8s infinite step-start; }
    .anim-hang { animation: hang 0.8s infinite step-start; }
    .anim-picked-up { animation: picked-up 0.8s infinite step-start; }
    .anim-falling { animation: falling 0.5s infinite step-start; }

</style>

<script>
    (function() {
        // --- CONFIGURATION ---
        const config = {
            width: 96,
            height: 96,
            gravity: 0.8,
            friction: 0.9,
            walkSpeed: 2,
            climbSpeed: 1.5,
            floorBuffer: 5, // Pixels from bottom considered "floor"
            folderPath: '/animations' // Ensure this matches your server path
        };

        // --- DYNAMIC CSS KEYFRAME GENERATOR ---
        // Generates keyframes for frame1.png to frame6.png for each state
        const styleSheet = document.createElement("style");
        const states = {
            'walk-left': 'walk left',
            'walk-right': 'walk right',
            'climb-left': 'climb left',
            'climb-right': 'climb right',
            'hang': 'hang',
            'picked-up': 'picked up',
            'falling': 'falling'
        };

        let cssOutput = "";
        
        for (const [animName, folderName] of Object.entries(states)) {
            cssOutput += `@keyframes ${animName} {`;
            for (let i = 1; i <= 6; i++) {
                // Calculate percentage: 0%, 16.6%, 33%...
                let percent = (i - 1) * (100 / 6); 
                cssOutput += `${percent}% { background-image: url('${config.folderPath}/${folderName}/frame${i}.png'); } `;
            }
            cssOutput += `}\n`;
        }
        styleSheet.innerText = cssOutput;
        document.head.appendChild(styleSheet);


        // --- THE PET BRAIN ---
        class PennPet {
            constructor() {
                this.el = document.getElementById('penn-pet-container');
                this.sprite = document.getElementById('penn-sprite');
                
                // Physics
                this.x = window.innerWidth / 2;
                this.y = window.innerHeight - config.height;
                this.vx = 0;
                this.vy = 0;

                // State
                this.state = 'idle'; // idle, walking, climbing, falling, dragged, hanging
                this.direction = 1; // 1 = right, -1 = left
                this.isDragging = false;
                this.mouseTarget = { x: null, y: null, active: false };
                this.dragOffset = { x: 0, y: 0 };
                
                // Timers
                this.decisionTimer = 0;
                this.nameTimer = null;

                this.initEvents();
                this.loop();
            }

            initEvents() {
                // Dragging Logic
                this.sprite.addEventListener('mousedown', (e) => {
                    this.isDragging = true;
                    this.state = 'dragged';
                    this.vx = 0;
                    this.vy = 0;
                    // Calculate offset so pet doesn't snap to corner
                    this.dragOffset.x = e.clientX - this.x;
                    this.dragOffset.y = e.clientY - this.y;
                    
                    // Name display logic
                    this.el.classList.add('show-name');
                });

                window.addEventListener('mousemove', (e) => {
                    this.mouseTarget.x = e.clientX;
                    this.mouseTarget.y = e.clientY;
                    this.mouseTarget.active = true;

                    if (this.isDragging) {
                        this.x = e.clientX - this.dragOffset.x;
                        this.y = e.clientY - this.dragOffset.y;
                    }
                });

                window.addEventListener('mouseup', () => {
                    if (this.isDragging) {
                        this.isDragging = false;
                        this.state = 'falling';
                        this.el.classList.remove('show-name');
                    }
                });

                // Resize handler
                window.addEventListener('resize', () => {
                    if (this.x > window.innerWidth - config.width) {
                        this.x = window.innerWidth - config.width;
                    }
                });
            }

            setAnimation(animName) {
                // Remove all anim classes
                const classes = this.sprite.classList;
                for (let i = classes.length - 1; i >= 0; i--) {
                    if (classes[i].startsWith('anim-')) classes.remove(classes[i]);
                }
                // Add new one
                if (animName) this.sprite.classList.add(animName);
            }

            decideNextMove() {
                // Simple AI: Every 1-3 seconds, pick a new action if not busy
                if (this.decisionTimer > 0) {
                    this.decisionTimer--;
                    return;
                }
                
                this.decisionTimer = Math.random() * 200 + 100; // Reset timer

                // If mouse is active and far away, maybe follow it?
                if (this.mouseTarget.active) {
                    const dx = this.mouseTarget.x - (this.x + config.width/2);
                    if (Math.abs(dx) > 100) {
                         this.direction = dx > 0 ? 1 : -1;
                         this.state = 'walking';
                         return;
                    }
                }

                // Random Walk
                const r = Math.random();
                if (r < 0.3) this.state = 'idle';
                else if (r < 0.6) {
                    this.state = 'walking';
                    this.direction = Math.random() > 0.5 ? 1 : -1;
                }
            }

            updatePhysics() {
                const floorY = window.innerHeight - config.height;
                const rightWall = window.innerWidth - config.width;

                // 1. DRAGGING
                if (this.state === 'dragged') {
                    this.setAnimation('anim-picked-up');
                    return; // Physics is manual
                }

                // 2. FALLING
                if (this.y < floorY && this.state !== 'climbing') {
                    this.state = 'falling';
                    this.vy += config.gravity;
                    this.y += this.vy;
                    
                    if (this.y >= floorY) {
                        this.y = floorY;
                        this.vy = 0;
                        this.state = 'idle'; // Landed
                    }
                    this.setAnimation('anim-falling');
                    return;
                }

                // 3. CLIMBING (Boundary Interaction)
                if (this.state === 'climbing') {
                    // Try to reach mouse height
                    const targetY = this.mouseTarget.active ? this.mouseTarget.y : this.y;
                    
                    if (this.y > targetY) this.y -= config.climbSpeed;
                    else if (this.y < targetY) this.y += config.climbSpeed;

                    // If we hit the floor, walk
                    if (this.y >= floorY) {
                        this.y = floorY;
                        this.state = 'idle';
                    }
                    
                    // If mouse moves away from wall, fall or jump off
                    if (this.x === 0 && this.mouseTarget.x > 200) this.state = 'falling';
                    if (this.x >= rightWall && this.mouseTarget.x < rightWall - 200) this.state = 'falling';

                    this.setAnimation(this.x <= 0 ? 'anim-climb-left' : 'anim-climb-right');
                    return;
                }

                // 4. WALKING / IDLE
                this.decideNextMove();

                if (this.state === 'walking') {
                    this.x += config.walkSpeed * this.direction;

                    // Wall Detection
                    if (this.x <= 0) {
                        this.x = 0;
                        // Determine if we should climb (is mouse high?)
                        if (this.mouseTarget.y < this.y - 100) {
                            this.state = 'climbing';
                        } else {
                            this.direction = 1; // Turn around
                        }
                    } else if (this.x >= rightWall) {
                        this.x = rightWall;
                        if (this.mouseTarget.y < this.y - 100) {
                            this.state = 'climbing';
                        } else {
                            this.direction = -1; // Turn around
                        }
                    }

                    this.setAnimation(this.direction === 1 ? 'anim-walk-right' : 'anim-walk-left');
                } else if (this.state === 'idle') {
                    // Just stand there (first frame of walk usually, or custom idle)
                    // We'll use walk animation paused or specific idle if you had one.
                    // For now, let's use 'anim-walk-right' but we won't move X
                    this.setAnimation(this.direction === 1 ? 'anim-walk-right' : 'anim-walk-left');
                }
            }

            loop() {
                this.updatePhysics();
                
                // Render
                this.el.style.left = `${this.x}px`;
                this.el.style.top = `${this.y}px`;

                requestAnimationFrame(() => this.loop());
            }
        }

        // Initialize when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => new PennPet());
        } else {
            new PennPet();
        }
    })();
</script>
