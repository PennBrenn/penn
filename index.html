<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Deep Space Navigator V2.0</title>
  <style>
    :root {
      --bg: #000000;
      --fg: #ffffff;
      --mid: #888888;
      --dim: #444444;
    }
    html, body {
      margin: 0;
      padding: 0;
      background: var(--bg);
      color: var(--fg);
      font-family: ui-monospace, Menlo, Consolas, monospace;
      overflow: hidden;
    }
    canvas {
      display: block;
      background: var(--bg);
    }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <script>
    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d", { willReadFrequently: true });

    const WORLD_W = 1600;
    const WORLD_H = 900;
    let scale = 1;
    let offsetX = 0;
    let offsetY = 0;

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      const sx = canvas.width / WORLD_W;
      const sy = canvas.height / WORLD_H;
      scale = Math.min(sx, sy);
      offsetX = (canvas.width - WORLD_W * scale) * 0.5;
      offsetY = (canvas.height - WORLD_H * scale) * 0.5;
    }
    window.addEventListener("resize", resize);
    resize();

    const G = 0.08;
    const SUBSTEPS = 5;
    const PHYSICS_HZ = 300;
    const PHYSICS_DT = 1 / PHYSICS_HZ;
    const REGISTRY = [];

    const ship = {
      pos: { x: 0, y: 0 },
      vel: { x: 0, y: 0 },
      acc: { x: 0, y: 0 },
      angle: 0,
      angVel: 0,
      mass: 1,
      thrustG: 1.0,
      maxAngAccel: 4.0,
      state: "TLI",
      target: null,
      trail: [],
      landed: false
    };

    const sun = {
      id: "Sol",
      mass: 80000,
      radius: 80,
      pos: { x: -800, y: 0 },
      vel: { x: 0, y: 0 },
      color: "#888888",
      noiseSeed: 12.34
    };
    const planetA = {
      id: "Aster",
      mass: 1200,
      radius: 55,
      pos: { x: 300, y: -260 },
      vel: { x: 0.2, y: 0.52 },
      color: "#444444",
      noiseSeed: 45.67
    };
    const planetB = {
      id: "Vanta",
      mass: 2600,
      radius: 70,
      pos: { x: 900, y: 120 },
      vel: { x: -0.18, y: 0.36 },
      color: "#888888",
      noiseSeed: 78.9
    };
    REGISTRY.push(sun, planetA, planetB);
    ship.target = planetB;

    let lastTime = performance.now();
    let accumulator = 0;
    let glitchTimer = 0;

    const particles = [];
    function spawnDust() {
      const count = 6;
      for (let i = 0; i < count; i++) {
        const spread = (Math.random() - 0.5) * 0.35;
        const dir = ship.angle + Math.PI + spread;
        const speed = 1.2 + Math.random() * 0.6;
        particles.push({
          x: 0,
          y: 0,
          vx: Math.cos(dir) * speed + ship.vel.x * 0.3,
          vy: Math.sin(dir) * speed + ship.vel.y * 0.3,
          life: 1.0
        });
      }
    }

    function noise1D(x, seed) {
      const s = Math.sin(x * 12.9898 + seed * 78.233) * 43758.5453;
      return s - Math.floor(s);
    }
    function fractalNoise(x, seed, octaves) {
      let amp = 1;
      let freq = 1;
      let sum = 0;
      let max = 0;
      for (let i = 0; i < octaves; i++) {
        sum += (noise1D(x * freq, seed + i * 3.7) - 0.5) * amp;
        max += amp;
        amp *= 0.55;
        freq *= 2.2;
      }
      return sum / max;
    }

    function toScreen(x, y) {
      return {
        x: offsetX + (x + WORLD_W / 2) * scale,
        y: offsetY + (y + WORLD_H / 2) * scale
      };
    }

    function fromScreen(x, y) {
      return {
        x: (x - offsetX) / scale - WORLD_W / 2,
        y: (y - offsetY) / scale - WORLD_H / 2
      };
    }

    function length(vx, vy) {
      return Math.hypot(vx, vy);
    }

    function normalize(vx, vy) {
      const l = Math.hypot(vx, vy) || 1;
      return { x: vx / l, y: vy / l };
    }

    function angleTo(vx, vy) {
      return Math.atan2(vy, vx);
    }

    function clamp(val, min, max) {
      return Math.max(min, Math.min(max, val));
    }

    function wrapAngle(a) {
      while (a > Math.PI) a -= Math.PI * 2;
      while (a < -Math.PI) a += Math.PI * 2;
      return a;
    }

    function nearestBody() {
      let best = null;
      let bestD = Infinity;
      for (const body of REGISTRY) {
        const dx = body.pos.x - ship.pos.x;
        const dy = body.pos.y - ship.pos.y;
        const d = Math.hypot(dx, dy) - body.radius;
        if (d < bestD) {
          bestD = d;
          best = body;
        }
      }
      return { body: best, distance: bestD };
    }

    function gravityAt(x, y) {
      let ax = 0;
      let ay = 0;
      for (const body of REGISTRY) {
        const dx = body.pos.x - x;
        const dy = body.pos.y - y;
        const r2 = dx * dx + dy * dy + 0.01;
        const r = Math.sqrt(r2);
        const f = (G * body.mass) / r2;
        ax += (dx / r) * f;
        ay += (dy / r) * f;
      }
      return { x: ax, y: ay };
    }

    function applyPID(targetAngle, dt) {
      const deadzone = 0.01;
      let error = wrapAngle(targetAngle - ship.angle);
      if (Math.abs(error) < deadzone) {
        error = 0;
      }
      const kp = 8.0;
      const kd = 3.4;
      const desired = kp * error - kd * ship.angVel;
      const angAccel = clamp(desired, -ship.maxAngAccel, ship.maxAngAccel);
      ship.angVel += angAccel * dt;
      ship.angle = wrapAngle(ship.angle + ship.angVel * dt);
    }

    function phaseLogic(dt) {
      if (!ship.target) return { thrust: 0 };
      const target = ship.target;
      const dx = target.pos.x - ship.pos.x;
      const dy = target.pos.y - ship.pos.y;
      const dist = Math.hypot(dx, dy);
      const speed = length(ship.vel.x, ship.vel.y);
      const maxAccel = ship.thrustG * 1.0;

      if (ship.state === "TLI") {
        const leadTime = clamp(dist / (speed + 0.5), 3, 20);
        const leadX = target.pos.x + target.vel.x * leadTime;
        const leadY = target.pos.y + target.vel.y * leadTime;
        const desiredAngle = angleTo(leadX - ship.pos.x, leadY - ship.pos.y);
        applyPID(desiredAngle, dt);
        const stoppingDist = (speed * speed) / (2 * maxAccel + 0.001);
        if (dist <= stoppingDist * 1.1) {
          ship.state = "FLIP";
        }
        return { thrust: 1.0 };
      }

      if (ship.state === "FLIP") {
        const desiredAngle = angleTo(-ship.vel.x, -ship.vel.y);
        applyPID(desiredAngle, dt);
        if (dist < target.radius * 6) {
          ship.state = "ORBIT";
        }
        return { thrust: 1.0 };
      }

      if (ship.state === "ORBIT") {
        const relVelX = ship.vel.x - target.vel.x;
        const relVelY = ship.vel.y - target.vel.y;
        const relPosX = ship.pos.x - target.pos.x;
        const relPosY = ship.pos.y - target.pos.y;
        const relDist = Math.hypot(relPosX, relPosY);
        const desiredRadius = target.radius * 1.5;
        const tangential = normalize(-relPosY, relPosX);
        const desiredSpeed = Math.sqrt((G * target.mass) / Math.max(desiredRadius, 1));
        const desiredVelX = target.vel.x + tangential.x * desiredSpeed;
        const desiredVelY = target.vel.y + tangential.y * desiredSpeed;
        const dvx = desiredVelX - ship.vel.x;
        const dvy = desiredVelY - ship.vel.y;
        const desiredAngle = angleTo(dvx, dvy);
        applyPID(desiredAngle, dt);
        const align = length(dvx, dvy);
        const thrust = clamp(align / 2.2, 0, 1);
        if (Math.abs(relDist - desiredRadius) < 6 && align < 0.4) {
          ship.state = "DESCENT";
        }
        return { thrust };
      }

      if (ship.state === "DESCENT") {
        const relVelX = ship.vel.x - target.vel.x;
        const relVelY = ship.vel.y - target.vel.y;
        const relPosX = ship.pos.x - target.pos.x;
        const relPosY = ship.pos.y - target.pos.y;
        const relDist = Math.hypot(relPosX, relPosY);
        const surfaceDist = relDist - target.radius;
        const normal = normalize(relPosX, relPosY);
        let desiredAngle = angleTo(-relVelX, -relVelY);
        if (surfaceDist < 50) {
          desiredAngle = angleTo(normal.x, normal.y);
        }
        applyPID(desiredAngle, dt);
        const slow = clamp(length(relVelX, relVelY) / 3.5, 0.2, 1);
        return { thrust: slow };
      }

      return { thrust: 0 };
    }

    function physicsStep(dt) {
      const control = phaseLogic(dt);
      const grav = gravityAt(ship.pos.x, ship.pos.y);
      const thrust = control.thrust || 0;
      const thrustAx = Math.cos(ship.angle) * ship.thrustG * thrust;
      const thrustAy = Math.sin(ship.angle) * ship.thrustG * thrust;
      ship.acc.x = grav.x + thrustAx;
      ship.acc.y = grav.y + thrustAy;

      if (thrust > 0.2) spawnDust();

      ship.vel.x += ship.acc.x * dt;
      ship.vel.y += ship.acc.y * dt;
      ship.pos.x += ship.vel.x * dt;
      ship.pos.y += ship.vel.y * dt;

      for (const body of REGISTRY) {
        let ax = 0;
        let ay = 0;
        for (const other of REGISTRY) {
          if (other === body) continue;
          const dx = other.pos.x - body.pos.x;
          const dy = other.pos.y - body.pos.y;
          const r2 = dx * dx + dy * dy + 0.01;
          const r = Math.sqrt(r2);
          const f = (G * other.mass) / r2;
          ax += (dx / r) * f;
          ay += (dy / r) * f;
        }
        body.vel.x += ax * dt;
        body.vel.y += ay * dt;
        body.pos.x += body.vel.x * dt;
        body.pos.y += body.vel.y * dt;
      }

      for (const p of particles) {
        p.x += p.vx * dt * 60;
        p.y += p.vy * dt * 60;
        p.life -= dt * 0.35;
      }
      for (let i = particles.length - 1; i >= 0; i--) {
        if (particles[i].life <= 0) particles.splice(i, 1);
      }

      ship.trail.push({ x: ship.pos.x, y: ship.pos.y });
      if (ship.trail.length > 140) ship.trail.shift();

      const { body: near, distance } = nearestBody();
      if (!ship.landed && distance < 2) {
        const relVx = ship.vel.x - near.vel.x;
        const relVy = ship.vel.y - near.vel.y;
        const relSpeed = Math.hypot(relVx, relVy);
        if (relSpeed < 0.6 && ship.state === "DESCENT") {
          ship.landed = true;
          playPing();
        } else {
          triggerGlitch();
        }
      }

      if (!ship.landed) {
        const driftX = ship.pos.x;
        const driftY = ship.pos.y;
        ship.pos.x = 0;
        ship.pos.y = 0;
        for (const body of REGISTRY) {
          body.pos.x -= driftX;
          body.pos.y -= driftY;
        }
        for (const p of particles) {
          p.x -= driftX;
          p.y -= driftY;
        }
        for (const t of ship.trail) {
          t.x -= driftX;
          t.y -= driftY;
        }
      }
    }

    function drawPlanet(body) {
      const screen = toScreen(body.pos.x, body.pos.y);
      const r = body.radius * scale;
      const zoom = clamp(240 / (Math.abs(body.pos.x) + Math.abs(body.pos.y) + 200), 0.5, 4.0);
      const octaves = zoom > 1.2 ? 5 : 3;
      ctx.beginPath();
      ctx.arc(screen.x, screen.y, r, 0, Math.PI * 2);
      ctx.strokeStyle = "#888888";
      ctx.stroke();

      ctx.save();
      ctx.beginPath();
      ctx.arc(screen.x, screen.y, r, 0, Math.PI * 2);
      ctx.clip();
      ctx.strokeStyle = body.color;
      ctx.lineWidth = 1;
      for (let a = 0; a < Math.PI * 2; a += Math.PI / 64) {
        const n = fractalNoise(a * 1.8, body.noiseSeed, octaves);
        const rr = r + n * r * 0.1;
        ctx.beginPath();
        ctx.moveTo(screen.x, screen.y);
        ctx.lineTo(screen.x + Math.cos(a) * rr, screen.y + Math.sin(a) * rr);
        ctx.stroke();
      }
      ctx.restore();
    }

    function drawShip(x, y, angle, color) {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(angle);
      ctx.strokeStyle = color;
      ctx.beginPath();
      ctx.moveTo(12, 0);
      ctx.lineTo(-8, -6);
      ctx.lineTo(-4, 0);
      ctx.lineTo(-8, 6);
      ctx.closePath();
      ctx.stroke();
      ctx.restore();
    }

    function drawHUD() {
      const pad = 16;
      const navR = 60;
      ctx.save();
      ctx.translate(offsetX + pad + navR, offsetY + pad + navR);
      ctx.strokeStyle = "#444444";
      ctx.beginPath();
      ctx.arc(0, 0, navR, 0, Math.PI * 2);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(-navR, 0);
      ctx.lineTo(navR, 0);
      ctx.moveTo(0, -navR);
      ctx.lineTo(0, navR);
      ctx.stroke();
      ctx.strokeStyle = "#888888";
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(Math.cos(ship.angle) * navR, Math.sin(ship.angle) * navR);
      ctx.stroke();
      ctx.restore();

      const gForce = Math.hypot(ship.acc.x, ship.acc.y);
      const gHeight = clamp(gForce / 2.5, 0, 1) * 120;
      const jitter = gForce > 2 ? (Math.random() - 0.5) * 6 : 0;
      const barX = offsetX + pad + 10 + jitter;
      const barY = offsetY + pad + 150;
      ctx.strokeStyle = "#444444";
      ctx.strokeRect(barX, barY - 120, 10, 120);
      ctx.fillStyle = "#888888";
      ctx.fillRect(barX, barY - gHeight, 10, gHeight);

      ctx.fillStyle = "#888888";
      ctx.fillText(`STATE: ${ship.state}`, offsetX + pad, offsetY + pad + 180);
      if (ship.target) {
        ctx.fillText(`TARGET: ${ship.target.id}`, offsetX + pad, offsetY + pad + 200);
      }
    }

    function drawTrail() {
      ctx.save();
      for (let i = 0; i < ship.trail.length; i++) {
        const t = ship.trail[i];
        const alpha = i / ship.trail.length;
        const p = toScreen(t.x, t.y);
        ctx.fillStyle = `rgba(255,255,255,${alpha * 0.4})`;
        ctx.fillRect(p.x, p.y, 2, 2);
      }
      ctx.restore();
    }

    function draw() {
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "#000000";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.strokeStyle = "#444444";
      ctx.strokeRect(offsetX, offsetY, WORLD_W * scale, WORLD_H * scale);

      drawTrail();

      for (const body of REGISTRY) {
        drawPlanet(body);
      }

      for (const p of particles) {
        const screen = toScreen(p.x, p.y);
        ctx.fillStyle = `rgba(255,255,255,${p.life * 0.5})`;
        ctx.fillRect(screen.x, screen.y, 2, 2);
      }

      const futureX = ship.vel.x * 5;
      const futureY = ship.vel.y * 5;
      const ghost = toScreen(futureX, futureY);
      drawShip(ghost.x, ghost.y, ship.angle, "#444444");

      const shipScreen = toScreen(0, 0);
      drawShip(shipScreen.x, shipScreen.y, ship.angle, "#ffffff");

      drawHUD();

      if (glitchTimer > 0) {
        const img = ctx.getImageData(0, 0, canvas.width, canvas.height);
        for (let y = 0; y < img.height; y += 4) {
          const shift = (Math.random() - 0.5) * 12;
          for (let x = 0; x < img.width; x++) {
            const src = (y * img.width + x) * 4;
            const nx = Math.max(0, Math.min(img.width - 1, x + shift));
            const dst = (y * img.width + nx) * 4;
            img.data[dst] = img.data[src];
            img.data[dst + 1] = img.data[src + 1];
            img.data[dst + 2] = img.data[src + 2];
            img.data[dst + 3] = img.data[src + 3];
          }
        }
        ctx.putImageData(img, 0, 0);
      }
    }

    function triggerGlitch() {
      if (glitchTimer > 0) return;
      glitchTimer = 0.5;
    }

    function resetSim() {
      ship.pos = { x: 0, y: 0 };
      ship.vel = { x: 0, y: 0 };
      ship.angle = 0;
      ship.angVel = 0;
      ship.state = "TLI";
      ship.landed = false;
      ship.trail = [];
      particles.length = 0;
    }

    let audioCtx = null;
    let engineOsc = null;
    let engineFilter = null;
    let noiseSource = null;
    let noiseGain = null;

    function setupAudio() {
      if (audioCtx) return;
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      engineOsc = audioCtx.createOscillator();
      engineOsc.type = "sawtooth";
      engineFilter = audioCtx.createBiquadFilter();
      engineFilter.type = "lowpass";
      engineFilter.frequency.value = 220;
      const engineGain = audioCtx.createGain();
      engineGain.gain.value = 0.08;
      engineOsc.connect(engineFilter).connect(engineGain).connect(audioCtx.destination);
      engineOsc.start();

      const bufferSize = 2 * audioCtx.sampleRate;
      const noiseBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
      const data = noiseBuffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) {
        data[i] = Math.random() * 2 - 1;
      }
      noiseSource = audioCtx.createBufferSource();
      noiseSource.buffer = noiseBuffer;
      noiseSource.loop = true;
      noiseGain = audioCtx.createGain();
      noiseGain.gain.value = 0.03;
      noiseSource.connect(noiseGain).connect(audioCtx.destination);
      noiseSource.start();
    }

    function updateAudio(thrust, voidLevel) {
      if (!audioCtx) return;
      engineFilter.frequency.value = 140 + thrust * 480;
      engineOsc.frequency.value = 80 + thrust * 120;
      noiseGain.gain.value = 0.01 + voidLevel * 0.08;
    }

    function playPing() {
      if (!audioCtx) return;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = "sine";
      osc.frequency.value = 520;
      gain.gain.setValueAtTime(0.12, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.6);
      osc.connect(gain).connect(audioCtx.destination);
      osc.start();
      osc.stop(audioCtx.currentTime + 0.6);
    }

    function tick(now) {
      const dt = (now - lastTime) / 1000;
      lastTime = now;
      accumulator += dt;
      const maxStep = 0.06;
      const step = Math.min(accumulator, maxStep);
      const subDt = step / SUBSTEPS;
      for (let i = 0; i < SUBSTEPS; i++) {
        physicsStep(subDt);
      }
      accumulator -= step;

      const thrustLevel = ship.landed ? 0 : Math.min(1, Math.hypot(ship.acc.x, ship.acc.y));
      const { distance } = nearestBody();
      const voidLevel = clamp(distance / 400, 0, 1);
      updateAudio(thrustLevel, voidLevel);

      if (glitchTimer > 0) {
        glitchTimer -= dt;
        if (glitchTimer <= 0) {
          resetSim();
          glitchTimer = 0;
        }
      }

      draw();
      requestAnimationFrame(tick);
    }

    canvas.addEventListener("click", (e) => {
      setupAudio();
      if (audioCtx && audioCtx.state === "suspended") audioCtx.resume();
      const pos = fromScreen(e.clientX, e.clientY);
      let hit = null;
      for (const body of REGISTRY) {
        const dx = pos.x - body.pos.x;
        const dy = pos.y - body.pos.y;
        if (Math.hypot(dx, dy) < body.radius + 6) {
          hit = body;
          break;
        }
      }
      if (hit) {
        ship.target = hit;
        ship.state = "TLI";
        ship.landed = false;
      }
    });

    requestAnimationFrame(tick);
  </script>
</body>
</html>
