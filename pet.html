<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Interactive Site Pet (page-mate)</title>
<style>
  :root{
    /* Replace this URL with your sprite path if needed */
    --sprite-url: url('pet-sprite.png');
    --frame-w: 96px;
    --frame-h: 96px;
    --sheet-w: 288px; /* 3 * 96 */
    --sheet-h: 192px; /* 2 * 96 */
  }

  /* Make sure this doesn't break existing layout -- the pet will sit on top */
  .site-pet {
    position: fixed;
    left: 20px;
    top: 20px;
    width: var(--frame-w);
    height: var(--frame-h);
    z-index: 9999;
    pointer-events: auto; /* allow clicking */
    user-select: none;
    touch-action: none;
    will-change: transform;
    transition: transform 0.08s linear; /* helps smooth flips */
  }

  .site-pet .sprite {
    width: 100%;
    height: 100%;
    background-image: var(--sprite-url);
    background-size: var(--sheet-w) var(--sheet-h);
    /* start at frame 0 */
    background-position: 0 0;
    image-rendering: pixelated; /* optional, for crisp sprites */
  }

  /* FLIP when moving left */
  .flip { transform: scaleX(-1); }

  /* Different animation classes (JS toggles these) */
  .anim-idle .sprite { animation: idle-anim 1s steps(1) infinite; }
  .anim-walk .sprite { animation: walk-top 0.6s steps(3) infinite; }
  .anim-climb .sprite { animation: climb-bottom 0.8s steps(3) infinite; }
  .anim-fall  .sprite { animation: fall-anim 0.4s steps(1) infinite; }

  /* KEYFRAMES: top row = frames 0..2 (left-to-right), bottom row = frames 3..5 */
  @keyframes walk-top {
    0%   { background-position: 0 0; }
    33%  { background-position: -96px 0; }
    66%  { background-position: -192px 0; }
    100% { background-position: 0 0; }
  }
  @keyframes climb-bottom {
    0%   { background-position: 0 -96px; }
    33%  { background-position: -96px -96px; }
    66%  { background-position: -192px -96px; }
    100% { background-position: 0 -96px; }
  }
  /* idle shows first top-frame */
  @keyframes idle-anim {
    0%   { background-position: 0 0; }
    100% { background-position: 0 0; }
  }
  /* falling uses a single bottom-row middle frame (use frame 4) */
  @keyframes fall-anim {
    0%   { background-position: -96px -96px; }
    100% { background-position: -96px -96px; }
  }

  /* optional: add a small shadow so it's easier to see */
  .site-pet .shadow{
    position: absolute;
    left: 10%;
    right: 10%;
    bottom: -6px;
    height: 8px;
    border-radius: 50%;
    filter: blur(2px);
    background: rgba(0,0,0,0.25);
    transform-origin: center;
    transition: opacity 0.15s linear, transform 0.15s linear;
    pointer-events: none;
  }
  .hidden { opacity: 0; pointer-events: none; }
  /* when falling, make shadow smaller */
  .falling .shadow { transform: scale(0.6); opacity: 0.6; }
</style>
</head>
<body>

<!-- You can drop this div into your site wherever you like. -->
<div id="sitePet" class="site-pet anim-idle" aria-hidden="true" title="Page pet (drag me!)">
  <div class="sprite"></div>
  <div class="shadow"></div>
</div>

<script>
/*
Interactive Site Pet
- Drop into an existing page.
- Edit sprite path via CSS variable --sprite-url or replace the <style>.
- Uses requestAnimationFrame for smooth movement.
*/

(function() {
  const petEl = document.getElementById('sitePet');
  const spriteEl = petEl.querySelector('.sprite');
  const shadowEl = petEl.querySelector('.shadow');

  // Config
  const FRAME_W = 96;
  const FRAME_H = 96;
  const gravity = 1500; // px/s^2
  const walkSpeedRange = [60, 140]; // px/s
  const changeDirInterval = [1500, 4500]; // ms between random behavior changes
  const followRadius = 160; // how close the cursor must be to trigger follow
  const followSpeed = 280; // speed when following cursor px/s
  const groundPadding = 4; // small gap considered "on ground"

  // State
  const state = {
    x: 20,
    y: 20,
    vx: 80, // px/s
    vy: 0,
    targetVX: null,
    width: FRAME_W,
    height: FRAME_H,
    dragging: false,
    dragOffsetX: 0,
    dragOffsetY: 0,
    lastTime: null,
    mode: 'idle', // idle, walk, climb, fall, follow
    facing: 1, // 1 = right, -1 = left
    mouseX: null,
    mouseY: null,
    nextBehaviorChange: Date.now() + randBetween(...changeDirInterval),
  };

  // helpers
  function randBetween(a,b){ return Math.random()*(b-a)+a; }
  function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
  function setMode(m){
    if (state.mode === m) return;
    state.mode = m;
    petEl.classList.remove('anim-idle','anim-walk','anim-climb','anim-fall');
    switch(m){
      case 'walk': petEl.classList.add('anim-walk'); break;
      case 'climb': petEl.classList.add('anim-climb'); break;
      case 'fall': petEl.classList.add('anim-fall'); break;
      default: petEl.classList.add('anim-idle'); break;
    }
    // add falling class for shadow adjustments
    if(m==='fall'){ petEl.classList.add('falling'); }
    else { petEl.classList.remove('falling'); }
  }

  // Place pet at initial transform
  function applyTransform(){
    petEl.style.transform = `translate3d(${state.x}px, ${state.y}px, 0) ${state.facing===-1? 'scaleX(-1)':''}`;
    // handle flip via class to avoid messing with other transforms
    if(state.facing === -1) petEl.classList.add('flip');
    else petEl.classList.remove('flip');
    // shadow scale/opacity based on height from ground
    const bottomY = window.innerHeight - state.height;
    const distToGround = Math.max(0, bottomY - state.y);
    const s = clamp(1 - distToGround / 800, 0.3, 1);
    shadowEl.style.transform = `scale(${s})`;
    shadowEl.style.opacity = (state.mode === 'fall' ? 0.6 : 0.9).toString();
  }

  // Mouse tracking for follow/hang
  window.addEventListener('mousemove', (ev) => {
    state.mouseX = ev.clientX;
    state.mouseY = ev.clientY;
  }, {passive:true});

  // Dragging
  petEl.addEventListener('mousedown', (ev) => {
    ev.preventDefault();
    state.dragging = true;
    const rect = petEl.getBoundingClientRect();
    state.dragOffsetX = ev.clientX - rect.left;
    state.dragOffsetY = ev.clientY - rect.top;
    setMode('idle');
    state.vx = 0;
    state.vy = 0;
  });
  window.addEventListener('mousemove', (ev) => {
    if(!state.dragging) return;
    state.x = clamp(ev.clientX - state.dragOffsetX, 0, window.innerWidth - state.width);
    state.y = clamp(ev.clientY - state.dragOffsetY, 0, window.innerHeight - state.height);
    applyTransform();
  }, {passive:true});
  window.addEventListener('mouseup', (ev) => {
    if(!state.dragging) return;
    state.dragging = false;
    // drop: start falling physics (unless already on ground)
    const bottomY = window.innerHeight - state.height;
    if (state.y + groundPadding < bottomY){
      // small initial downward velocity from release
      state.vy = 0;
      setMode('fall');
    } else {
      setMode('idle');
    }
  });

  // Touch support (basic)
  petEl.addEventListener('touchstart', (ev) => {
    const t = ev.touches[0];
    ev.preventDefault();
    state.dragging = true;
    const rect = petEl.getBoundingClientRect();
    state.dragOffsetX = t.clientX - rect.left;
    state.dragOffsetY = t.clientY - rect.top;
    setMode('idle');
    state.vx = 0;
    state.vy = 0;
  }, {passive:false});
  window.addEventListener('touchmove', (ev) => {
    if(!state.dragging) return;
    const t = ev.touches[0];
    state.x = clamp(t.clientX - state.dragOffsetX, 0, window.innerWidth - state.width);
    state.y = clamp(t.clientY - state.dragOffsetY, 0, window.innerHeight - state.height);
    applyTransform();
  }, {passive:false});
  window.addEventListener('touchend', (ev) => {
    if(!state.dragging) return;
    state.dragging = false;
    const bottomY = window.innerHeight - state.height;
    if (state.y + groundPadding < bottomY){
      state.vy = 0;
      setMode('fall');
    } else {
      setMode('idle');
    }
  });

  // When window resizes, ensure pet remains in viewport
  window.addEventListener('resize', () => {
    state.x = clamp(state.x, 0, window.innerWidth - state.width);
    state.y = clamp(state.y, 0, window.innerHeight - state.height);
    applyTransform();
  });

  // Behavior chooser: random walking, or follow mouse when near
  function chooseRandomBehavior(){
    const now = Date.now();
    if (now < state.nextBehaviorChange) return;
    state.nextBehaviorChange = now + randBetween(...changeDirInterval);

    // If mouse within followRadius, choose follow
    if (state.mouseX !== null && Math.hypot((state.mouseX - (state.x + state.width/2)), (state.mouseY - (state.y + state.height/2))) < followRadius) {
      state.targetVX = null;
      setMode('follow');
      return;
    }
    // Otherwise random walk or idle
    if (Math.random() < 0.7) {
      // pick a random vx sign and speed
      const s = randBetween(...walkSpeedRange) * (Math.random()<0.5 ? -1 : 1);
      state.targetVX = s;
      state.vx = s;
      setMode('walk');
      state.facing = s >= 0 ? 1 : -1;
    } else {
      state.targetVX = 0;
      state.vx = 0;
      setMode('idle');
    }
  }

  // Main loop
  function loop(ts){
    if (!state.lastTime) state.lastTime = ts;
    const dt = Math.min(60, ts - state.lastTime) / 1000; // clamp to avoid huge jumps
    state.lastTime = ts;

    if(!state.dragging){
      // If we are following mouse and it's near, move toward it
      if (state.mode === 'follow' && state.mouseX !== null){
        const centerX = state.x + state.width/2;
        const centerY = state.y + state.height/2;
        const dx = state.mouseX - centerX;
        const dy = state.mouseY - centerY;
        const dist = Math.hypot(dx, dy);
        if (dist < 18) {
          // reached close enough
          state.vx = 0;
          state.vy = 0;
          setMode('idle');
        } else {
          // normalized velocity toward cursor
          const nx = dx / dist;
          const ny = dy / dist;
          state.vx = nx * followSpeed;
          state.vy = ny * followSpeed;
          state.facing = state.vx >= 0 ? 1 : -1;
          setMode('walk');
          // but slow vertical movement when following so it "hangs"
          state.vy *= 0.6;
        }
        // if mouse moved away too far, revert to random behavior eventually
        if (dist > followRadius * 1.6) {
          state.nextBehaviorChange = Date.now() + randBetween(...changeDirInterval);
        }
      } else if (state.mode === 'fall'){
        // falling physics
        state.vy += gravity * dt;
        state.y += state.vy * dt;
        // small horizontal friction
        state.x += state.vx * dt;
        // detect ground collision
        const bottomY = window.innerHeight - state.height;
        if (state.y >= bottomY){
          state.y = bottomY;
          state.vy = 0;
          // when landing, go to idle
          setMode('idle');
          // small bounce effect
        }
      } else {
        // walking / idle behavior
        // If we have a targetVX, try to approach it
        if (state.targetVX !== null){
          // simple damping to target
          state.vx += (state.targetVX - state.vx) * clamp(8 * dt, 0, 1);
        }
        // move horizontally
        state.x += state.vx * dt;
        // slight vertical idle bob for character (makes it feel alive)
        state.y += Math.sin(ts/400 + state.x/200) * 0.2;

        // boundary detection (left/right/top/bottom)
        const maxX = window.innerWidth - state.width;
        const maxY = window.innerHeight - state.height;
        // left boundary
        if (state.x <= 0){
          state.x = 0;
          state.vx = Math.abs(state.vx) || randBetween(...walkSpeedRange);
          state.targetVX = state.vx;
          setMode('climb');
          state.facing = 1;
          state.nextBehaviorChange = Date.now() + 900; // pause a bit in climb
        }
        // right boundary
        if (state.x >= maxX){
          state.x = maxX;
          state.vx = -Math.abs(state.vx) || -randBetween(...walkSpeedRange);
          state.targetVX = state.vx;
          setMode('climb');
          state.facing = -1;
          state.nextBehaviorChange = Date.now() + 900;
        }
        // top boundary (simulate climbing up)
        if (state.y <= 0){
          state.y = 0;
          // when at top, reverse y slightly and stay in climb
          setMode('climb');
          state.vy = 0;
          state.nextBehaviorChange = Date.now() + 900;
        }
        // bottom boundary (ground)
        if (state.y >= maxY){
          state.y = maxY;
          // ensure falling state not stuck
          if (state.mode === 'fall') setMode('idle');
        }

        // occasionally switch behavior
        chooseRandomBehavior();

        // If mouse nearby, start follow mode
        if (state.mouseX !== null && Math.hypot((state.mouseX - (state.x + state.width/2)), (state.mouseY - (state.y + state.height/2))) < followRadius){
          setMode('follow');
        }
      }
    } // end not dragging

    // Ensure within viewport
    state.x = clamp(state.x, 0, Math.max(0, window.innerWidth - state.width));
    state.y = clamp(state.y, 0, Math.max(0, window.innerHeight - state.height));

    // Face direction
    if (Math.abs(state.vx) > 1) state.facing = state.vx >= 0 ? 1 : -1;

    applyTransform();

    requestAnimationFrame(loop);
  }

  // Initialize position and start loop
  applyTransform();
  requestAnimationFrame(loop);

  // small helper to set custom initial random movement
  state.vx = (Math.random() < 0.5 ? -1 : 1) * randBetween(...walkSpeedRange);
  state.targetVX = state.vx;
  setMode('walk');

  // Accessibility: allow user to hide pet via click+ctrl (example)
  window.addEventListener('keydown', (e) => {
    if (e.ctrlKey && e.key === 'h') {
      petEl.style.display = petEl.style.display === 'none' ? 'block' : 'none';
    }
  });

  // Expose API to page in case integrator wants to control pet
  window.pagePet = {
    setSprite(url){
      document.documentElement.style.setProperty('--sprite-url', `url('${url}')`);
    },
    setPosition(x,y){
      state.x = x; state.y = y;
      applyTransform();
    },
    hide(){ petEl.style.display='none'; },
    show(){ petEl.style.display='block'; },
    mode(){ return state.mode; }
  };
})();
</script>
</body>
</html>
