<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Orbital Mechanics Simulator</title>
    <style>
/* ============================================================================
   SECTION 0: CSS STYLES
   ============================================================================ */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    background: #000;
    overflow: hidden;
    font-family: 'Courier New', monospace;
    color: #ccc;
}

#gameCanvas {
    display: block;
    cursor: crosshair;
}

/* UI Overlay Styles */
#ui-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 100;
}

#ui-overlay > * {
    pointer-events: auto;
}

/* Navball Container */
#navball-container {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    width: 180px;
    height: 180px;
}

/* Instrument Panel */
#instrument-panel {
    position: fixed;
    top: 20px;
    left: 20px;
    background: rgba(20, 20, 20, 0.85);
    border: 1px solid #444;
    padding: 15px;
    min-width: 220px;
    font-size: 12px;
}

.instrument-row {
    display: flex;
    justify-content: space-between;
    margin: 5px 0;
    padding: 3px 0;
    border-bottom: 1px solid #333;
}

.instrument-label {
    color: #888;
}

.instrument-value {
    color: #fff;
    font-weight: bold;
}

/* Fuel Gauge */
#fuel-gauge {
    margin-top: 10px;
    height: 20px;
    background: #222;
    border: 1px solid #444;
    position: relative;
}

#fuel-bar {
    height: 100%;
    background: linear-gradient(90deg, #666, #aaa);
    transition: width 0.1s;
}

#fuel-text {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 10px;
}

/* Thermal Gauge */
#thermal-gauge {
    margin-top: 5px;
    height: 15px;
    background: #222;
    border: 1px solid #444;
    position: relative;
}

#thermal-bar {
    height: 100%;
    background: linear-gradient(90deg, #444, #888, #fff);
    width: 0%;
}

/* WRT Toggle */
#wrt-toggle {
    margin-top: 10px;
    padding: 5px 10px;
    background: #333;
    border: 1px solid #555;
    color: #fff;
    cursor: pointer;
    font-family: inherit;
    font-size: 11px;
}

#wrt-toggle:hover {
    background: #444;
}

/* Time Warp Panel */
#warp-panel {
    position: fixed;
    top: 20px;
    right: 20px;
    background: rgba(20, 20, 20, 0.85);
    border: 1px solid #444;
    padding: 15px;
    text-align: center;
}

#warp-chevrons {
    font-size: 24px;
    letter-spacing: 2px;
    margin: 10px 0;
}

#warp-rate {
    font-size: 14px;
    color: #aaa;
}

/* Mode Indicator */
#mode-indicator {
    position: fixed;
    top: 50%;
    left: 20px;
    transform: translateY(-50%);
    writing-mode: vertical-rl;
    text-orientation: mixed;
    font-size: 18px;
    letter-spacing: 5px;
    color: #555;
}

/* Planned Mode UI */
#planned-ui {
    position: fixed;
    bottom: 20px;
    right: 20px;
    background: rgba(20, 20, 20, 0.85);
    border: 1px solid #444;
    padding: 15px;
    display: none;
    min-width: 200px;
}

#maneuver-info {
    margin-bottom: 10px;
}

/* Target Info */
#target-panel {
    position: fixed;
    top: 200px;
    right: 20px;
    background: rgba(20, 20, 20, 0.85);
    border: 1px solid #444;
    padding: 15px;
    display: none;
    min-width: 180px;
}

/* Help Panel */
#help-panel {
    position: fixed;
    bottom: 20px;
    left: 20px;
    background: rgba(20, 20, 20, 0.7);
    border: 1px solid #333;
    padding: 10px;
    font-size: 10px;
    color: #666;
    max-width: 200px;
}

/* Landing Indicator */
#landing-indicator {
    position: fixed;
    bottom: 220px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(20, 20, 20, 0.85);
    border: 1px solid #444;
    padding: 10px 20px;
    display: none;
    text-align: center;
}

.landing-safe {
    color: #aaa;
}

.landing-danger {
    color: #fff;
    animation: blink 0.5s infinite;
}

@keyframes blink {
    50% { opacity: 0.5; }
}

/* Message Display */
#message-display {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 24px;
    color: #fff;
    text-align: center;
    opacity: 0;
    transition: opacity 0.5s;
    pointer-events: none;
}

/* System Name Display */
#system-name {
    position: fixed;
    top: 100px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 16px;
    color: #444;
    letter-spacing: 3px;
}

/* Burn Efficiency Indicator */
#burn-efficiency {
    position: fixed;
    bottom: 220px;
    right: 20px;
    background: rgba(20, 20, 20, 0.85);
    border: 1px solid #444;
    padding: 10px;
    display: none;
}

#efficiency-glow {
    width: 30px;
    height: 30px;
    border-radius: 50%;
    background: radial-gradient(circle, #fff 0%, #444 100%);
    margin: 0 auto;
}
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <!-- UI Overlay -->
    <div id="ui-overlay">
        <!-- Instrument Panel -->
        <div id="instrument-panel">
            <div class="instrument-row">
                <span class="instrument-label">ALT</span>
                <span class="instrument-value" id="altimeter">0 m</span>
            </div>
            <div class="instrument-row">
                <span class="instrument-label">VEL</span>
                <span class="instrument-value" id="velocity">0 m/s</span>
            </div>
            <div class="instrument-row">
                <span class="instrument-label">V-VRT</span>
                <span class="instrument-value" id="vertical-vel">0 m/s</span>
            </div>
            <div class="instrument-row">
                <span class="instrument-label">H-VRT</span>
                <span class="instrument-value" id="horizontal-vel">0 m/s</span>
            </div>
            <div class="instrument-row">
                <span class="instrument-label">SOI</span>
                <span class="instrument-value" id="current-soi">Sol</span>
            </div>
            <div class="instrument-row">
                <span class="instrument-label">AP</span>
                <span class="instrument-value" id="apoapsis">-- m</span>
            </div>
            <div class="instrument-row">
                <span class="instrument-label">PE</span>
                <span class="instrument-value" id="periapsis">-- m</span>
            </div>
            <div class="instrument-row">
                <span class="instrument-label">ECC</span>
                <span class="instrument-value" id="eccentricity">0.00</span>
            </div>
            <div id="fuel-gauge">
                <div id="fuel-bar" style="width: 100%"></div>
                <span id="fuel-text">1000 L</span>
            </div>
            <div id="thermal-gauge">
                <div id="thermal-bar"></div>
            </div>
            <button id="wrt-toggle">WRT: Surface</button>
        </div>

        <!-- Time Warp Panel -->
        <div id="warp-panel">
            <div>TIME WARP</div>
            <div id="warp-chevrons">▶</div>
            <div id="warp-rate">1x</div>
            <div style="font-size: 10px; color: #666; margin-top: 5px;">
                [,/.] to adjust
            </div>
        </div>

        <!-- Mode Indicator -->
        <div id="mode-indicator">MANUAL</div>

        <!-- Planned Mode UI -->
        <div id="planned-ui">
            <div style="margin-bottom: 10px; color: #888;">MANEUVER NODE</div>
            <div id="maneuver-info">
                <div class="instrument-row">
                    <span class="instrument-label">Δv</span>
                    <span class="instrument-value" id="node-dv">0 m/s</span>
                </div>
                <div class="instrument-row">
                    <span class="instrument-label">T-Burn</span>
                    <span class="instrument-value" id="time-to-burn">--:--</span>
                </div>
                <div class="instrument-row">
                    <span class="instrument-label">Δv Budget</span>
                    <span class="instrument-value" id="dv-budget">0 m/s</span>
                </div>
            </div>
            <div style="margin-top: 10px; border-top: 1px solid #333; padding-top: 10px;">
                <div style="color: #888; font-size: 10px;">HOHMANN TRANSFER</div>
                <div class="instrument-row">
                    <span class="instrument-label">To Target</span>
                    <span class="instrument-value" id="hohmann-dv">-- m/s</span>
                </div>
                <div class="instrument-row">
                    <span class="instrument-label">Phase Δ</span>
                    <span class="instrument-value" id="hohmann-phase">--°</span>
                </div>
            </div>
            <div style="font-size: 10px; color: #666; margin-top: 10px;">
                Click orbit to place node<br>
                Drag handles to adjust<br>
                ESC to cancel warp
            </div>
        </div>

        <!-- Target Panel -->
        <div id="target-panel">
            <div style="margin-bottom: 10px; color: #888;">TARGET</div>
            <div class="instrument-row">
                <span class="instrument-label">Name</span>
                <span class="instrument-value" id="target-name">--</span>
            </div>
            <div class="instrument-row">
                <span class="instrument-label">Dist</span>
                <span class="instrument-value" id="target-distance">-- m</span>
            </div>
            <div class="instrument-row">
                <span class="instrument-label">Rel V</span>
                <span class="instrument-value" id="target-relvel">-- m/s</span>
            </div>
            <div class="instrument-row">
                <span class="instrument-label">Phase</span>
                <span class="instrument-value" id="phase-angle">--°</span>
            </div>
        </div>

        <!-- Landing Indicator -->
        <div id="landing-indicator">
            <div id="landing-status">LANDING STATUS</div>
            <div id="landing-vel">V: 0 m/s</div>
            <div id="landing-angle">A: 0°</div>
        </div>

        <!-- Help Panel -->
        <div id="help-panel">
            <div><b>FLIGHT:</b></div>
            <div>WASD - Translate</div>
            <div>QE - Rotate</div>
            <div>Shift/Ctrl - Throttle</div>
            <div>Z/X - Max/Cut Throttle</div>
            <div><b>NAVIGATION:</b></div>
            <div>M - Toggle Mode</div>
            <div>[ ] - Warp Speed</div>
            <div>Space - Stop Warp</div>
            <div>P - Warp to PE</div>
            <div>O - Warp to AP</div>
            <div><b>INTERACTION:</b></div>
            <div>T - Cycle Target</div>
            <div>F - Plant Flag</div>
            <div>V - Survey (landed)</div>
            <div>Scroll - Zoom</div>
            <div>RMB Drag - Pan</div>
        </div>

        <!-- System Name -->
        <div id="system-name">SOL SYSTEM</div>

        <!-- Message Display -->
        <div id="message-display"></div>

        <!-- Burn Efficiency -->
        <div id="burn-efficiency">
            <div style="font-size: 10px; color: #888;">OBERTH</div>
            <div id="efficiency-glow"></div>
        </div>
        
        <!-- Minimap -->
        <div id="minimap-container" style="
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 150px;
            height: 150px;
            background: rgba(10, 10, 10, 0.8);
            border: 1px solid #333;
            display: none;
        ">
            <canvas id="minimap" width="150" height="150"></canvas>
        </div>
        
        <!-- Delta-V Readout -->
        <div id="dv-readout" style="
            position: fixed;
            bottom: 220px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(20, 20, 20, 0.85);
            border: 1px solid #444;
            padding: 5px 15px;
            font-size: 14px;
            display: none;
        ">
            <span style="color: #888;">Δv:</span>
            <span id="current-dv" style="color: #fff;">0 m/s</span>
        </div>
    </div>

    <script>
/* ============================================================================
   SECTION 1: CONSTANTS AND CONFIGURATION
   ============================================================================ */

// Universal Constants (scaled for gameplay)
const G = 6.674e-4;  // Scaled gravitational constant
const SCALE_FACTOR = 1;  // Pixels per meter at 1x zoom

// Ship Configuration
const SHIP_CONFIG = {
    dryMass: 1000,           // kg
    maxFuel: 1000,           // Liters
    fuelDensity: 0.8,        // kg/L
    exhaustVelocity: 3000,   // m/s (effective)
    maxThrust: 50000,        // Newtons
    rcsThrust: 500,          // Newtons
    dragCoefficient: 0.3,
    crossSection: 10,        // m^2
    heatCapacity: 1000,      // Arbitrary units
    maxHeat: 100,
    heatDissipation: 0.5,
    maxImpactVelocity: 8,    // m/s
    size: 10                 // pixels
};

// Physics Configuration
const PHYSICS_CONFIG = {
    verletDamping: 0.9999,
    maxSubsteps: 16,
    floatingOriginThreshold: 10000,
    soiTransitionSteps: 10,
    collisionIterations: 5
};

// Warp Levels
const WARP_LEVELS = [1, 2, 3, 4, 5, 10, 50, 100, 1000, 10000, 100000, 1000000];
const PHYSICS_WARP_MAX = 4;  // Index in WARP_LEVELS where on-rails begins

// Visual Configuration
const VISUAL_CONFIG = {
    gridSpacing: 1000,
    gridColor: '#1a1a1a',
    orbitLineSegments: 360,
    trailLength: 100,
    starFieldDensity: 200
};

/* ============================================================================
   SECTION 2: PSEUDO-RANDOM NUMBER GENERATOR (PRNG)
   Deterministic noise generation for procedural content
   ============================================================================ */

class SeededRandom {
    constructor(seed) {
        this.seed = this.hashString(seed);
        this.original = this.seed;
    }
    
    hashString(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash;
        }
        return Math.abs(hash) || 1;
    }
    
    next() {
        // Mulberry32 algorithm
        let t = this.seed += 0x6D2B79F5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
    }
    
    range(min, max) {
        return min + this.next() * (max - min);
    }
    
    int(min, max) {
        return Math.floor(this.range(min, max + 1));
    }
    
    reset() {
        this.seed = this.original;
    }
    
    fork(suffix) {
        return new SeededRandom(this.original.toString() + suffix);
    }
}

/* ============================================================================
   SECTION 3: PROCEDURAL NAME GENERATOR (Lexicon Engine)
   ============================================================================ */

const LEXICON = {
    prefixes: ['Aeon', 'Bel', 'Cor', 'Dra', 'Exo', 'Flor', 'Glie', 'Hel', 'Ion', 
               'Juna', 'Kora', 'Lyra', 'Mith', 'Nova', 'Ophi', 'Prax', 'Quo', 
               'Rho', 'Tyra', 'Urs', 'Val', 'Xan', 'Yps', 'Zeph', 'Ara', 'Cep',
               'Eri', 'Pyx', 'Vel', 'Cru', 'Lup', 'Nor', 'Sco', 'Ser', 'Vul'],
    infixes: ['an', 'or', 'on', 'is', 'ar', 'el', 'am', 'in', 'ut', 'ec', 'id', 
              'os', 'ax', 'ix', 'um', 'en', 'al', 'ir', 'eth', 'oth'],
    suffixes: ['ia', 'ius', 'prime', 'major', 'minor', 'cluster', 'station', 
               'outpost', 'terminus', 'point', 'nexus', 'beta', 'gamma', 
               'alpha', 'delta', 'sigma', 'omega', 'haven', 'reach', 'expanse']
};

function generateName(rng, type, complexity = 1) {
    const prefix = LEXICON.prefixes[rng.int(0, LEXICON.prefixes.length - 1)];
    
    if (complexity === 0) {
        // Simple: just prefix
        return prefix;
    } else if (complexity === 1) {
        // Medium: prefix + suffix
        const suffix = LEXICON.suffixes[rng.int(0, LEXICON.suffixes.length - 1)];
        return prefix + '-' + suffix;
    } else {
        // Complex: prefix + infix + suffix
        const infix = LEXICON.infixes[rng.int(0, LEXICON.infixes.length - 1)];
        const suffix = LEXICON.suffixes[rng.int(0, LEXICON.suffixes.length - 1)];
        return prefix + infix + '-' + suffix;
    }
}

function generateAsteroidName(rng) {
    const prefix = LEXICON.prefixes[rng.int(0, LEXICON.prefixes.length - 1)];
    const hex = rng.int(0, 65535).toString(16).toUpperCase().padStart(4, '0');
    return prefix + '-' + hex;
}

/* ============================================================================
   SECTION 4: VECTOR MATHEMATICS
   ============================================================================ */

class Vec2 {
    constructor(x = 0, y = 0) {
        this.x = x;
        this.y = y;
    }
    
    clone() {
        return new Vec2(this.x, this.y);
    }
    
    add(v) {
        return new Vec2(this.x + v.x, this.y + v.y);
    }
    
    sub(v) {
        return new Vec2(this.x - v.x, this.y - v.y);
    }
    
    mul(s) {
        return new Vec2(this.x * s, this.y * s);
    }
    
    div(s) {
        return new Vec2(this.x / s, this.y / s);
    }
    
    dot(v) {
        return this.x * v.x + this.y * v.y;
    }
    
    cross(v) {
        return this.x * v.y - this.y * v.x;
    }
    
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    
    lengthSq() {
        return this.x * this.x + this.y * this.y;
    }
    
    normalize() {
        const len = this.length();
        if (len === 0) return new Vec2(0, 0);
        return this.div(len);
    }
    
    rotate(angle) {
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        return new Vec2(
            this.x * cos - this.y * sin,
            this.x * sin + this.y * cos
        );
    }
    
    angle() {
        return Math.atan2(this.y, this.x);
    }
    
    lerp(v, t) {
        return new Vec2(
            this.x + (v.x - this.x) * t,
            this.y + (v.y - this.y) * t
        );
    }
    
    static fromAngle(angle, length = 1) {
        return new Vec2(Math.cos(angle) * length, Math.sin(angle) * length);
    }
    
    static distance(a, b) {
        return a.sub(b).length();
    }
}

/* ============================================================================
   SECTION 5: ORBITAL MECHANICS CALCULATIONS
   ============================================================================ */

class OrbitalMechanics {
    // Calculate standard gravitational parameter
    static getMu(mass) {
        return G * mass;
    }
    
    // Calculate surface gravity from density and radius
    static getSurfaceGravity(radius, density) {
        return (4/3) * G * Math.PI * radius * density;
    }
    
    // Calculate SOI radius
    static getSOIRadius(semiMajorAxis, planetMass, parentMass) {
        return semiMajorAxis * Math.pow(planetMass / parentMass, 0.4);
    }
    
    // Vis-viva equation: velocity at distance r
    static getOrbitalVelocity(mu, r, a) {
        if (a <= 0) {
            // Escape trajectory
            return Math.sqrt(2 * mu / r);
        }
        return Math.sqrt(mu * (2/r - 1/a));
    }
    
    // Calculate orbital elements from state vectors
    static stateToOrbital(position, velocity, mu) {
        const r = position.length();
        const v = velocity.length();
        
        // Specific orbital energy
        const energy = (v * v / 2) - (mu / r);
        
        // Semi-major axis
        let a;
        if (Math.abs(energy) < 1e-10) {
            a = Infinity; // Parabolic
        } else {
            a = -mu / (2 * energy);
        }
        
        // Eccentricity vector
        const evec = position.mul(v * v / mu - 1 / r).sub(velocity.mul(position.dot(velocity) / mu));
        const e = evec.length();
        
        // Angular momentum
        const h = position.cross(velocity);
        
        // Argument of periapsis
        let omega = Math.atan2(evec.y, evec.x);
        if (omega < 0) omega += 2 * Math.PI;
        
        // True anomaly
        let nu;
        if (e < 1e-10) {
            // Circular orbit
            nu = Math.atan2(position.y, position.x);
        } else {
            const cosNu = evec.dot(position) / (e * r);
            const sinNu = h * (evec.dot(velocity)) / (e * mu);
            nu = Math.atan2(Math.sign(h) * Math.sqrt(1 - cosNu * cosNu), cosNu);
        }
        if (nu < 0) nu += 2 * Math.PI;
        
        // Periapsis and apoapsis
        const pe = a * (1 - e);
        const ap = e < 1 ? a * (1 + e) : Infinity;
        
        // Orbital period
        const period = a > 0 ? 2 * Math.PI * Math.sqrt(a * a * a / mu) : Infinity;
        
        return { a, e, omega, nu, pe, ap, period, h, energy };
    }
    
    // Calculate position from orbital elements at true anomaly
    static orbitalToPosition(a, e, omega, nu) {
        if (a <= 0 || !isFinite(a)) return new Vec2(0, 0);
        
        const r = a * (1 - e * e) / (1 + e * Math.cos(nu));
        const angle = omega + nu;
        return Vec2.fromAngle(angle, r);
    }
    
    // Mean anomaly to eccentric anomaly (Newton-Raphson)
    static meanToEccentric(M, e, tolerance = 1e-8, maxIter = 50) {
        // Initial guess
        let E = e > 0.8 ? Math.PI : M;
        
        for (let i = 0; i < maxIter; i++) {
            const dE = (E - e * Math.sin(E) - M) / (1 - e * Math.cos(E));
            E -= dE;
            if (Math.abs(dE) < tolerance) break;
        }
        
        return E;
    }
    
    // Eccentric anomaly to true anomaly
    static eccentricToTrue(E, e) {
        return 2 * Math.atan2(
            Math.sqrt(1 + e) * Math.sin(E / 2),
            Math.sqrt(1 - e) * Math.cos(E / 2)
        );
    }
    
    // True anomaly to eccentric anomaly
    static trueToEccentric(nu, e) {
        return 2 * Math.atan2(
            Math.sqrt(1 - e) * Math.sin(nu / 2),
            Math.sqrt(1 + e) * Math.cos(nu / 2)
        );
    }
    
    // Eccentric anomaly to mean anomaly
    static eccentricToMean(E, e) {
        return E - e * Math.sin(E);
    }
    
    // Propagate orbit by time (on-rails)
    static propagateOrbit(elements, mu, dt) {
        const { a, e, omega, nu } = elements;
        
        if (e >= 1 || a <= 0) {
            // Hyperbolic/parabolic - use different method
            return this.propagateHyperbolic(elements, mu, dt);
        }
        
        // Mean motion
        const n = Math.sqrt(mu / (a * a * a));
        
        // Current mean anomaly
        const E0 = this.trueToEccentric(nu, e);
        const M0 = this.eccentricToMean(E0, e);
        
        // New mean anomaly
        let M1 = M0 + n * dt;
        M1 = ((M1 % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);
        
        // Solve for new eccentric anomaly
        const E1 = this.meanToEccentric(M1, e);
        
        // New true anomaly
        const nu1 = this.eccentricToTrue(E1, e);
        
        // New position
        const pos = this.orbitalToPosition(a, e, omega, nu1);
        
        // New velocity (tangent to orbit)
        const r = pos.length();
        const vMag = this.getOrbitalVelocity(mu, r, a);
        const flightPathAngle = Math.atan2(e * Math.sin(nu1), 1 + e * Math.cos(nu1));
        const velAngle = omega + nu1 + Math.PI/2 - flightPathAngle;
        const vel = Vec2.fromAngle(velAngle, vMag);
        
        return { position: pos, velocity: vel, nu: nu1 };
    }
    
    // Propagate hyperbolic trajectory
    static propagateHyperbolic(elements, mu, dt) {
        const { a, e, omega, nu } = elements;
        
        // For hyperbolic, use direct integration
        const pos = this.orbitalToPosition(Math.abs(a), e, omega, nu);
        const r = pos.length();
        const vMag = Math.sqrt(mu * (2/r + 1/Math.abs(a)));
        
        // Approximate propagation
        const angularVel = Math.sqrt(mu / (r * r * r));
        const dNu = angularVel * dt;
        const nu1 = nu + dNu;
        
        const pos1 = this.orbitalToPosition(Math.abs(a), e, omega, nu1);
        const vel1 = pos1.sub(pos).normalize().mul(vMag);
        
        return { position: pos1, velocity: vel1, nu: nu1 };
    }
    
    // Calculate Hohmann transfer parameters
    static hohmannTransfer(r1, r2, mu) {
        const aTransfer = (r1 + r2) / 2;
        const v1Circular = Math.sqrt(mu / r1);
        const v1Transfer = Math.sqrt(mu * (2/r1 - 1/aTransfer));
        const v2Transfer = Math.sqrt(mu * (2/r2 - 1/aTransfer));
        const v2Circular = Math.sqrt(mu / r2);
        
        const dv1 = Math.abs(v1Transfer - v1Circular);
        const dv2 = Math.abs(v2Circular - v2Transfer);
        const transferTime = Math.PI * Math.sqrt(aTransfer * aTransfer * aTransfer / mu);
        
        return { dv1, dv2, totalDv: dv1 + dv2, transferTime, aTransfer };
    }
    
    // Calculate phase angle for transfer
    static calculatePhaseAngle(r1, r2, mu) {
        const aTransfer = (r1 + r2) / 2;
        const transferTime = Math.PI * Math.sqrt(aTransfer * aTransfer * aTransfer / mu);
        const targetAngularVel = Math.sqrt(mu / (r2 * r2 * r2));
        const angleTraversed = targetAngularVel * transferTime;
        return Math.PI - angleTraversed;
    }
    
    // Generate orbit points for rendering
    static getOrbitPoints(a, e, omega, numPoints = 360) {
        const points = [];
        
        if (e >= 1) {
            // Hyperbolic orbit - only draw part of it
            const maxNu = Math.acos(-1/e) * 0.95;
            for (let i = 0; i < numPoints; i++) {
                const t = (i / (numPoints - 1)) * 2 - 1;
                const nu = t * maxNu;
                const r = Math.abs(a) * (e * e - 1) / (1 + e * Math.cos(nu));
                if (r > 0 && r < 1e9) {
                    const angle = omega + nu;
                    points.push(Vec2.fromAngle(angle, r));
                }
            }
        } else {
            // Elliptical orbit
            for (let i = 0; i < numPoints; i++) {
                const nu = (i / numPoints) * 2 * Math.PI;
                const r = a * (1 - e * e) / (1 + e * Math.cos(nu));
                const angle = omega + nu;
                points.push(Vec2.fromAngle(angle, r));
            }
        }
        
        return points;
    }
}

/* ============================================================================
   SECTION 6: TERRAIN GENERATION
   Procedural 1D noise loop for planet surfaces
   ============================================================================ */

class TerrainGenerator {
    constructor(seed, numPoints = 360, baseRadius = 1000) {
        this.rng = new SeededRandom(seed);
        this.numPoints = numPoints;
        this.baseRadius = baseRadius;
        this.heights = [];
        this.generate();
    }
    
    generate() {
        // Generate heights using multiple octaves of noise
        const octaves = 5;
        const persistence = 0.5;
        const baseAmplitude = this.baseRadius * 0.05;
        
        for (let i = 0; i < this.numPoints; i++) {
            let height = 0;
            let amplitude = baseAmplitude;
            let frequency = 1;
            
            for (let o = 0; o < octaves; o++) {
                const angle = (i * frequency / this.numPoints) * Math.PI * 2;
                // Simple noise approximation
                const noise = this.noiseAt(i * frequency, o);
                height += noise * amplitude;
                amplitude *= persistence;
                frequency *= 2;
            }
            
            this.heights.push(this.baseRadius + height);
        }
        
        // Ensure loop is seamless
        this.smoothLoop();
    }
    
    noiseAt(x, octave) {
        const seed = this.rng.original + octave * 1000;
        const rng = new SeededRandom(seed.toString() + Math.floor(x).toString());
        const v1 = rng.next() * 2 - 1;
        rng.seed = rng.hashString(seed.toString() + (Math.floor(x) + 1).toString());
        const v2 = rng.next() * 2 - 1;
        const t = x - Math.floor(x);
        // Smoothstep interpolation
        const smooth = t * t * (3 - 2 * t);
        return v1 + (v2 - v1) * smooth;
    }
    
    smoothLoop() {
        // Blend the end points for seamless loop
        const blendRange = Math.floor(this.numPoints * 0.1);
        for (let i = 0; i < blendRange; i++) {
            const t = i / blendRange;
            const smooth = t * t * (3 - 2 * t);
            const startIdx = i;
            const endIdx = this.numPoints - blendRange + i;
            const avg = (this.heights[startIdx] + this.heights[endIdx]) / 2;
            this.heights[startIdx] = this.heights[startIdx] * (1 - smooth * 0.5) + avg * smooth * 0.5;
            this.heights[endIdx] = this.heights[endIdx] * (1 - smooth * 0.5) + avg * smooth * 0.5;
        }
    }
    
    getHeightAtAngle(angle) {
        // Normalize angle to 0-2PI
        while (angle < 0) angle += Math.PI * 2;
        while (angle >= Math.PI * 2) angle -= Math.PI * 2;
        
        // Find the two surrounding points
        const t = (angle / (Math.PI * 2)) * this.numPoints;
        const i0 = Math.floor(t) % this.numPoints;
        const i1 = (i0 + 1) % this.numPoints;
        const fract = t - Math.floor(t);
        
        // Linear interpolation
        return this.heights[i0] + (this.heights[i1] - this.heights[i0]) * fract;
    }
    
    getSurfaceNormal(angle) {
        const delta = 0.01;
        const h1 = this.getHeightAtAngle(angle - delta);
        const h2 = this.getHeightAtAngle(angle + delta);
        
        // Calculate tangent and rotate 90 degrees for normal
        const p1 = Vec2.fromAngle(angle - delta, h1);
        const p2 = Vec2.fromAngle(angle + delta, h2);
        const tangent = p2.sub(p1).normalize();
        
        // Normal is perpendicular to tangent (rotate 90 degrees CCW)
        return new Vec2(-tangent.y, tangent.x);
    }
    
    getPoints() {
        const points = [];
        for (let i = 0; i < this.numPoints; i++) {
            const angle = (i / this.numPoints) * Math.PI * 2;
            const r = this.heights[i];
            points.push(Vec2.fromAngle(angle, r));
        }
        return points;
    }
}

/* ============================================================================
   SECTION 7: CELESTIAL BODY CLASS
   ============================================================================ */

class CelestialBody {
    constructor(config) {
        this.id = config.id;
        this.name = config.name || 'Unknown';
        this.type = config.type; // 'star', 'planet', 'moon', 'asteroid'
        this.mass = config.mass;
        this.baseRadius = config.radius;
        this.density = config.density || (3 * config.mass) / (4 * Math.PI * Math.pow(config.radius, 3));
        
        // Orbital parameters (null for star)
        this.parent = config.parent || null;
        this.semiMajorAxis = config.sma || 0;
        this.eccentricity = config.eccentricity || 0;
        this.argumentOfPeriapsis = config.aop || 0;
        this.trueAnomaly = config.nu || 0;
        
        // Calculated values
        this.mu = OrbitalMechanics.getMu(this.mass);
        this.surfaceGravity = OrbitalMechanics.getSurfaceGravity(this.baseRadius, this.density);
        
        // SOI (calculated relative to parent)
        this.soiRadius = config.soiRadius || (this.parent ? 
            OrbitalMechanics.getSOIRadius(this.semiMajorAxis, this.mass, this.parent.mass) : 
            Infinity);
        
        // Position and velocity
        this.position = new Vec2(0, 0);
        this.velocity = new Vec2(0, 0);
        
        // Terrain (for solid bodies)
        this.terrain = null;
        if (this.type !== 'star' && config.hasTerrain !== false) {
            this.terrain = new TerrainGenerator(config.terrainSeed || this.id, 360, this.baseRadius);
        }
        
        // Atmosphere
        this.hasAtmosphere = config.hasAtmosphere || false;
        this.atmosphereHeight = config.atmosphereHeight || 0;
        this.surfacePressure = config.surfacePressure || 0;
        this.scaleHeight = config.scaleHeight || 0;
        
        // Visual properties
        this.color = config.color || '#888888';
        this.pattern = config.pattern || 'solid'; // 'solid', 'striped', 'dotted', 'rings'
        this.ringInner = config.ringInner || 0;
        this.ringOuter = config.ringOuter || 0;
        
        // Children (moons)
        this.children = [];
        
        // Rotation
        this.rotationPeriod = config.rotationPeriod || 86400;
        this.rotationAngle = 0;
    }
    
    update(dt, parentPosition = null) {
        if (this.parent && parentPosition) {
            const mu = this.parent.mu;
            
            // Propagate orbital position
            const elements = {
                a: this.semiMajorAxis,
                e: this.eccentricity,
                omega: this.argumentOfPeriapsis,
                nu: this.trueAnomaly
            };
            
            const result = OrbitalMechanics.propagateOrbit(elements, mu, dt);
            this.trueAnomaly = result.nu;
            
            // Update position relative to parent
            this.position = parentPosition.add(result.position);
            this.velocity = result.velocity;
        }
        
        // Update rotation
        this.rotationAngle += (2 * Math.PI / this.rotationPeriod) * dt;
        
        // Update children
        for (const child of this.children) {
            child.update(dt, this.position);
        }
    }
    
    getAtmosphericDensity(altitude) {
        if (!this.hasAtmosphere || altitude > this.atmosphereHeight) return 0;
        return this.surfacePressure * Math.exp(-altitude / this.scaleHeight);
    }
    
    getTerrainHeight(angle) {
        if (this.terrain) {
            return this.terrain.getHeightAtAngle(angle);
        }
        return this.baseRadius;
    }
    
    getSurfaceNormal(angle) {
        if (this.terrain) {
            return this.terrain.getSurfaceNormal(angle);
        }
        return Vec2.fromAngle(angle, 1);
    }
    
    getMaxTerrainHeight() {
        if (this.terrain) {
            return Math.max(...this.terrain.heights);
        }
        return this.baseRadius;
    }
}

/* ============================================================================
   SECTION 8: SHIP CLASS
   ============================================================================ */

class Ship {
    constructor() {
        // Position and velocity
        this.position = new Vec2(0, 0);
        this.velocity = new Vec2(0, 0);
        this.prevPosition = new Vec2(0, 0);
        
        // Rotation
        this.angle = 0;
        this.angularVelocity = 0;
        
        // Mass
        this.fuel = SHIP_CONFIG.maxFuel;
        this.getMass = () => SHIP_CONFIG.dryMass + this.fuel * SHIP_CONFIG.fuelDensity;
        
        // Throttle
        this.throttle = 0;
        
        // State
        this.isLanded = false;
        this.landedOn = null;
        this.landedAngle = 0;
        
        // Heat
        this.heat = 0;
        
        // Damage
        this.engineDamage = 0;
        this.structuralStrain = 0;
        
        // Current SOI
        this.currentSOI = null;
        
        // Input state
        this.input = {
            forward: false,
            backward: false,
            left: false,
            right: false,
            rotateLeft: false,
            rotateRight: false,
            throttleUp: false,
            throttleDown: false
        };
        
        // Trail for visual effect
        this.trail = [];
        this.maxTrailLength = 100;
    }
    
    applyThrust(dt) {
        if (this.fuel <= 0 || this.isLanded) return;
        
        let effectiveThrottle = this.throttle;
        
        // Low fuel stutter
        if (this.fuel < SHIP_CONFIG.maxFuel * 0.05) {
            effectiveThrottle = Math.min(effectiveThrottle, 0.25);
            if (Math.random() < 0.3) effectiveThrottle = 0;
        }
        
        // Engine damage
        if (this.engineDamage > 0) {
            effectiveThrottle *= (1 - this.engineDamage * 0.5);
            // Thrust jitter
            this.angle += (Math.random() - 0.5) * this.engineDamage * 0.1;
        }
        
        if (effectiveThrottle > 0) {
            const thrust = SHIP_CONFIG.maxThrust * effectiveThrottle;
            const thrustDir = Vec2.fromAngle(this.angle);
            const acc = thrustDir.mul(thrust / this.getMass());
            
            this.velocity = this.velocity.add(acc.mul(dt));
            
            // Fuel consumption (Tsiolkovsky consideration)
            const fuelRate = thrust / (SHIP_CONFIG.exhaustVelocity * SHIP_CONFIG.fuelDensity * 9.81);
            this.fuel = Math.max(0, this.fuel - fuelRate * dt);
        }
    }
    
    applyRCS(dt) {
        if (this.fuel <= 0) return;
        
        const rcsForce = SHIP_CONFIG.rcsThrust;
        const fuelPerRCS = 0.01;
        
        // Translation
        if (this.input.forward) {
            const acc = Vec2.fromAngle(this.angle).mul(rcsForce / this.getMass());
            this.velocity = this.velocity.add(acc.mul(dt));
            this.fuel = Math.max(0, this.fuel - fuelPerRCS * dt);
        }
        if (this.input.backward) {
            const acc = Vec2.fromAngle(this.angle + Math.PI).mul(rcsForce / this.getMass());
            this.velocity = this.velocity.add(acc.mul(dt));
            this.fuel = Math.max(0, this.fuel - fuelPerRCS * dt);
        }
        if (this.input.left) {
            const acc = Vec2.fromAngle(this.angle - Math.PI/2).mul(rcsForce / this.getMass());
            this.velocity = this.velocity.add(acc.mul(dt));
            this.fuel = Math.max(0, this.fuel - fuelPerRCS * dt);
        }
        if (this.input.right) {
            const acc = Vec2.fromAngle(this.angle + Math.PI/2).mul(rcsForce / this.getMass());
            this.velocity = this.velocity.add(acc.mul(dt));
            this.fuel = Math.max(0, this.fuel - fuelPerRCS * dt);
        }
        
        // Rotation
        const torque = 0.5;
        if (this.input.rotateLeft) {
            this.angularVelocity -= torque * dt;
            this.fuel = Math.max(0, this.fuel - fuelPerRCS * 0.5 * dt);
        }
        if (this.input.rotateRight) {
            this.angularVelocity += torque * dt;
            this.fuel = Math.max(0, this.fuel - fuelPerRCS * 0.5 * dt);
        }
    }
    
    calculateDeltaV() {
        const m0 = this.getMass();
        const mf = SHIP_CONFIG.dryMass;
        return SHIP_CONFIG.exhaustVelocity * Math.log(m0 / mf);
    }
    
    updateTrail() {
        this.trail.push(this.position.clone());
        if (this.trail.length > this.maxTrailLength) {
            this.trail.shift();
        }
    }
    
    reset(position, velocity) {
        this.position = position.clone();
        this.velocity = velocity.clone();
        this.prevPosition = position.clone();
        this.angle = 0;
        this.angularVelocity = 0;
        this.throttle = 0;
        this.isLanded = false;
        this.landedOn = null;
        this.heat = 0;
        this.engineDamage = 0;
        this.structuralStrain = 0;
        this.trail = [];
    }
}

/* ============================================================================
   SECTION 9: FLAG AND MARKER CLASSES
   ============================================================================ */

class Flag {
    constructor(bodyId, angle, label) {
        this.bodyId = bodyId;
        this.angle = angle;
        this.label = label;
        this.timestamp = Date.now();
    }
}

class ManeuverNode {
    constructor(position, time, deltaV) {
        this.position = position.clone();
        this.time = time;
        this.deltaV = deltaV.clone();
        this.prograde = 0;
        this.radial = 0;
        this.executed = false;
    }
    
    getTotalDeltaV() {
        return this.deltaV.length();
    }
}

/* ============================================================================
   SECTION 10: SOLAR SYSTEM GENERATOR
   ============================================================================ */

class SolarSystemGenerator {
    constructor(universalSeed) {
        this.universalSeed = universalSeed;
        this.rng = new SeededRandom(universalSeed);
        this.bodies = new Map();
        this.asteroids = [];
    }
    
    generate() {
        // Generate Sol (the star)
        const sol = this.generateStar();
        this.bodies.set(sol.id, sol);
        
        // Generate planets
        const numPlanets = this.rng.int(4, 8);
        let currentDistance = 15000;
        
        for (let i = 0; i < numPlanets; i++) {
            const planetRng = this.rng.fork('planet' + i);
            const planet = this.generatePlanet(sol, currentDistance, i, planetRng);
            this.bodies.set(planet.id, planet);
            sol.children.push(planet);
            
            // Generate moons for this planet
            const numMoons = planetRng.int(0, 3);
            let moonDistance = planet.baseRadius * 3;
            
            for (let j = 0; j < numMoons; j++) {
                const moonRng = planetRng.fork('moon' + j);
                const moon = this.generateMoon(planet, moonDistance, j, moonRng);
                this.bodies.set(moon.id, moon);
                planet.children.push(moon);
                moonDistance += moonRng.range(500, 1500);
            }
            
            currentDistance += this.rng.range(20000, 50000);
        }
        
        // Generate asteroid belt
        this.generateAsteroidBelt(sol);
        
        return sol;
    }
    
    generateStar() {
        return new CelestialBody({
            id: 'sol',
            name: 'Sol',
            type: 'star',
            mass: 1.989e10,
            radius: 5000,
            color: '#ffffff',
            hasTerrain: false,
            rotationPeriod: 2160000
        });
    }
    
    generatePlanet(parent, distance, index, rng) {
        const isGasGiant = rng.next() > 0.6;
        const radius = isGasGiant ? rng.range(8000, 25000) : rng.range(2000, 6000);
        const density = isGasGiant ? rng.range(500, 1500) : rng.range(3000, 6000);
        const mass = (4/3) * Math.PI * Math.pow(radius, 3) * density * 1e-9;
        
        const name = generateName(rng, 'planet', isGasGiant ? 2 : 1);
        
        const hasAtmosphere = rng.next() > 0.3;
        const atmosphereHeight = hasAtmosphere ? radius * rng.range(0.05, 0.2) : 0;
        
        // Orbital parameters
        const eccentricity = rng.range(0, 0.15);
        const aop = rng.range(0, Math.PI * 2);
        const nu = rng.range(0, Math.PI * 2);
        
        return new CelestialBody({
            id: 'planet_' + index,
            name: name,
            type: 'planet',
            mass: mass,
            radius: radius,
            density: density,
            parent: parent,
            sma: distance,
            eccentricity: eccentricity,
            aop: aop,
            nu: nu,
            terrainSeed: this.universalSeed + '_planet_' + index,
            hasAtmosphere: hasAtmosphere,
            atmosphereHeight: atmosphereHeight,
            surfacePressure: hasAtmosphere ? rng.range(0.1, 2) : 0,
            scaleHeight: atmosphereHeight / 5,
            color: isGasGiant ? '#aa9988' : '#888888',
            pattern: isGasGiant ? 'striped' : 'dotted',
            ringInner: isGasGiant && rng.next() > 0.7 ? radius * 1.5 : 0,
            ringOuter: isGasGiant && rng.next() > 0.7 ? radius * 2.5 : 0,
            rotationPeriod: rng.range(20000, 200000)
        });
    }
    
    generateMoon(parent, distance, index, rng) {
        const radius = rng.range(300, 1500);
        const density = rng.range(2000, 4000);
        const mass = (4/3) * Math.PI * Math.pow(radius, 3) * density * 1e-12;
        
        const name = parent.name + ' ' + ['I', 'II', 'III', 'IV', 'V'][index];
        
        return new CelestialBody({
            id: parent.id + '_moon_' + index,
            name: name,
            type: 'moon',
            mass: mass,
            radius: radius,
            density: density,
            parent: parent,
            sma: distance,
            eccentricity: rng.range(0, 0.05),
            aop: rng.range(0, Math.PI * 2),
            nu: rng.range(0, Math.PI * 2),
            terrainSeed: this.universalSeed + '_' + parent.id + '_moon_' + index,
            color: '#666666',
            pattern: 'crosshatch',
            rotationPeriod: rng.range(50000, 500000)
        });
    }
    
    generateAsteroidBelt(parent) {
        const beltDistance = 80000;
        const beltWidth = 15000;
        const numAsteroids = 500;
        
        const rng = this.rng.fork('asteroids');
        
        for (let i = 0; i < numAsteroids; i++) {
            const asteroidRng = rng.fork('asteroid' + i);
            const distance = beltDistance + asteroidRng.range(-beltWidth/2, beltWidth/2);
            const radius = asteroidRng.range(25, 75);
            const mass = (4/3) * Math.PI * Math.pow(radius, 3) * 3000 * 1e-15;
            
            const asteroid = {
                id: 'asteroid_' + i,
                name: generateAsteroidName(asteroidRng),
                position: new Vec2(0, 0),
                velocity: new Vec2(0, 0),
                radius: radius,
                mass: mass,
                sma: distance,
                eccentricity: asteroidRng.range(0, 0.2),
                aop: asteroidRng.range(0, Math.PI * 2),
                nu: asteroidRng.range(0, Math.PI * 2),
                rotationAngle: 0,
                rotationSpeed: asteroidRng.range(0.01, 0.1)
            };
            
            this.asteroids.push(asteroid);
        }
    }
    
    updateAsteroids(dt, parentPosition, parentMu) {
        for (const asteroid of this.asteroids) {
            const elements = {
                a: asteroid.sma,
                e: asteroid.eccentricity,
                omega: asteroid.aop,
                nu: asteroid.nu
            };
            
            const result = OrbitalMechanics.propagateOrbit(elements, parentMu, dt);
            asteroid.nu = result.nu;
            asteroid.position = parentPosition.add(result.position);
            asteroid.velocity = result.velocity;
            asteroid.rotationAngle += asteroid.rotationSpeed * dt;
        }
    }
    
    getNearestAsteroids(position, count = 10) {
        return this.asteroids
            .map(a => ({ asteroid: a, dist: Vec2.distance(a.position, position) }))
            .sort((a, b) => a.dist - b.dist)
            .slice(0, count)
            .map(a => a.asteroid);
    }
}

/* ============================================================================
   SECTION 11: PHYSICS ENGINE
   ============================================================================ */

class PhysicsEngine {
    constructor(game) {
        this.game = game;
    }
    
    update(dt) {
        const ship = this.game.ship;
        const warpLevel = this.game.warpLevel;
        
        if (ship.isLanded) {
            this.updateLandedShip(dt);
            return;
        }
        
        // Determine if we're in physics warp or on-rails
        if (warpLevel <= PHYSICS_WARP_MAX) {
            this.physicsWarpUpdate(dt, WARP_LEVELS[warpLevel]);
        } else {
            this.onRailsUpdate(dt, WARP_LEVELS[warpLevel]);
        }
    }
    
    physicsWarpUpdate(dt, warpFactor) {
        const steps = Math.ceil(warpFactor);
        const subDt = dt / steps;
        
        for (let i = 0; i < steps; i++) {
            this.singlePhysicsStep(subDt);
        }
    }
    
    singlePhysicsStep(dt) {
        const ship = this.game.ship;
        
        // Store previous position for Verlet
        const prevPos = ship.position.clone();
        
        // Apply player input
        ship.applyRCS(dt);
        ship.applyThrust(dt);
        
        // Apply gravity
        const gravity = this.calculateGravity(ship.position);
        ship.velocity = ship.velocity.add(gravity.mul(dt));
        
        // Apply atmospheric drag
        if (ship.currentSOI && ship.currentSOI.hasAtmosphere) {
            this.applyAtmosphericEffects(dt);
        }
        
        // Verlet integration
        const newPos = ship.position.add(ship.velocity.mul(dt));
        ship.prevPosition = prevPos;
        ship.position = newPos;
        
        // Update rotation
        ship.angle += ship.angularVelocity * dt;
        ship.angularVelocity *= 0.99; // Angular damping
        
        // Heat dissipation
        ship.heat = Math.max(0, ship.heat - SHIP_CONFIG.heatDissipation * dt);
        
        // Check for collisions
        this.checkCollisions();
        
        // Check SOI transitions
        this.checkSOITransition();
        
        // Check floating origin
        this.checkFloatingOrigin();
        
        // Update trail
        ship.updateTrail();
    }
    
    onRailsUpdate(dt, warpFactor) {
        const ship = this.game.ship;
        const simulatedDt = dt * warpFactor;
        
        // Get current orbital elements
        const soi = ship.currentSOI || this.game.sol;
        const relPos = ship.position.sub(soi.position);
        const elements = OrbitalMechanics.stateToOrbital(relPos, ship.velocity, soi.mu);
        
        // Check for SOI transition with binary search
        const transitionTime = this.findSOITransition(elements, soi, simulatedDt);
        
        if (transitionTime !== null) {
            // Propagate to transition point and handle
            const result = OrbitalMechanics.propagateOrbit(elements, soi.mu, transitionTime);
            ship.position = soi.position.add(result.position);
            ship.velocity = result.velocity;
            this.checkSOITransition();
            
            // Lower warp
            this.game.warpLevel = 0;
            this.game.showMessage('SOI Transition - Warp Stopped');
        } else {
            // Safe to propagate full time
            const result = OrbitalMechanics.propagateOrbit(elements, soi.mu, simulatedDt);
            ship.position = soi.position.add(result.position);
            ship.velocity = result.velocity;
        }
        
        // Check periapsis danger
        if (elements.pe < soi.getMaxTerrainHeight() + 1000) {
            if (warpFactor > 10) {
                this.game.warpLevel = 4; // Cap at 5x
                this.game.showMessage('Periapsis Warning - Warp Limited');
            }
        }
    }
    
    findSOITransition(elements, currentSOI, totalDt) {
        const steps = 20;
        const stepDt = totalDt / steps;
        
        for (let i = 1; i <= steps; i++) {
            const t = stepDt * i;
            const result = OrbitalMechanics.propagateOrbit(elements, currentSOI.mu, t);
            const pos = currentSOI.position.add(result.position);
            
            // Check if we've left current SOI
            if (currentSOI.type !== 'star') {
                const distToParent = Vec2.distance(pos, currentSOI.position);
                if (distToParent > currentSOI.soiRadius) {
                    // Binary search for exact transition
                    return this.binarySearchTransition(elements, currentSOI, t - stepDt, t, 
                        (p) => Vec2.distance(p, currentSOI.position) > currentSOI.soiRadius);
                }
            }
            
            // Check if we've entered a child SOI
            const bodies = currentSOI.type === 'star' ? 
                Array.from(this.game.solarSystem.bodies.values()).filter(b => b.type === 'planet') :
                currentSOI.children;
                
            for (const body of bodies) {
                const distToBody = Vec2.distance(pos, body.position);
                if (distToBody < body.soiRadius) {
                    return this.binarySearchTransition(elements, currentSOI, t - stepDt, t,
                        (p) => Vec2.distance(p, body.position) < body.soiRadius);
                }
            }
        }
        
        return null;
    }
    
    binarySearchTransition(elements, soi, t0, t1, condition, iterations = 10) {
        for (let i = 0; i < iterations; i++) {
            const tMid = (t0 + t1) / 2;
            const result = OrbitalMechanics.propagateOrbit(elements, soi.mu, tMid);
            const pos = soi.position.add(result.position);
            
            if (condition(pos)) {
                t1 = tMid;
            } else {
                t0 = tMid;
            }
        }
        
        return (t0 + t1) / 2;
    }
    
    calculateGravity(position) {
        let totalGravity = new Vec2(0, 0);
        
        // Get dominant body (current SOI)
        const soi = this.game.ship.currentSOI || this.game.sol;
        
        // Gravity from SOI body
        const r = position.sub(soi.position);
        const dist = r.length();
        if (dist > 0) {
            const gMag = soi.mu / (dist * dist);
            totalGravity = r.normalize().mul(-gMag);
        }
        
        return totalGravity;
    }
    
    applyAtmosphericEffects(dt) {
        const ship = this.game.ship;
        const soi = ship.currentSOI;
        
        const relPos = ship.position.sub(soi.position);
        const altitude = relPos.length() - soi.getTerrainHeight(relPos.angle());
        
        if (altitude < soi.atmosphereHeight) {
            const density = soi.getAtmosphericDensity(altitude);
            const relVel = ship.velocity.sub(soi.velocity);
            const speed = relVel.length();
            
            // Drag force
            const dragMag = 0.5 * density * speed * speed * SHIP_CONFIG.dragCoefficient * SHIP_CONFIG.crossSection;
            const drag = relVel.normalize().mul(-dragMag / ship.getMass());
            ship.velocity = ship.velocity.add(drag.mul(dt));
            
            // Heat accumulation
            const heatRate = 0.001 * density * speed * speed * speed;
            ship.heat = Math.min(SHIP_CONFIG.maxHeat, ship.heat + heatRate * dt);
            
            // Check for heat death
            if (ship.heat >= SHIP_CONFIG.maxHeat) {
                this.game.triggerCrash('THERMAL FAILURE');
            }
        }
    }
    
    checkCollisions() {
        const ship = this.game.ship;
        
        // Check against all bodies
        for (const body of this.game.solarSystem.bodies.values()) {
            if (body.type === 'star') continue;
            
            const relPos = ship.position.sub(body.position);
            const dist = relPos.length();
            const angle = relPos.angle();
            const terrainHeight = body.getTerrainHeight(angle);
            
            if (dist <= terrainHeight) {
                this.handleBodyCollision(body, relPos, angle);
                return;
            }
        }
        
        // Check against nearby asteroids
        const nearAsteroids = this.game.solarSystem.getNearestAsteroids(ship.position, 10);
        for (const asteroid of nearAsteroids) {
            const dist = Vec2.distance(ship.position, asteroid.position);
            if (dist < asteroid.radius + SHIP_CONFIG.size) {
                this.handleAsteroidCollision(asteroid);
                return;
            }
        }
    }
    
    handleBodyCollision(body, relPos, angle) {
        const ship = this.game.ship;
        
        // Get relative velocity
        const relVel = ship.velocity.sub(body.velocity);
        const impactSpeed = relVel.length();
        
        // Get surface normal
        const surfaceNormal = body.getSurfaceNormal(angle);
        
        // Check landing conditions
        const shipUp = Vec2.fromAngle(ship.angle - Math.PI/2);
        const alignment = Math.abs(shipUp.dot(surfaceNormal));
        
        const canLand = impactSpeed < SHIP_CONFIG.maxImpactVelocity &&
                       alignment > 0.966 && // ~15 degrees
                       this.isLandingGearFirst(ship, surfaceNormal);
        
        if (canLand) {
            // Successful landing
            ship.isLanded = true;
            ship.landedOn = body;
            ship.landedAngle = angle;
            ship.velocity = body.velocity.clone();
            ship.angularVelocity = 0;
            
            // Position on surface
            const height = body.getTerrainHeight(angle);
            ship.position = body.position.add(Vec2.fromAngle(angle, height + 5));
            
            this.game.showMessage('LANDED on ' + body.name);
        } else {
            // Crash
            if (impactSpeed > SHIP_CONFIG.maxImpactVelocity * 2) {
                this.game.triggerCrash('IMPACT VELOCITY TOO HIGH');
            } else if (alignment < 0.866) {
                this.game.triggerCrash('MISALIGNMENT');
            } else {
                this.game.triggerCrash('LANDING GEAR NOT FIRST');
            }
        }
    }
    
    handleAsteroidCollision(asteroid) {
        const ship = this.game.ship;
        const relVel = ship.velocity.sub(asteroid.velocity);
        const impactSpeed = relVel.length();
        
        if (impactSpeed < SHIP_CONFIG.maxImpactVelocity) {
            ship.velocity = asteroid.velocity.clone();
            this.game.showMessage('Docked with ' + asteroid.name);
        } else {
            this.game.triggerCrash('ASTEROID COLLISION');
        }
    }
    
    isLandingGearFirst(ship, surfaceNormal) {
        // Landing gear is at the bottom of the ship (opposite of nose)
        const shipDown = Vec2.fromAngle(ship.angle + Math.PI/2);
        return shipDown.dot(surfaceNormal.mul(-1)) > 0.5;
    }
    
    checkSOITransition() {
        const ship = this.game.ship;
        const currentSOI = ship.currentSOI || this.game.sol;
        
        // Check if we've left current SOI
        if (currentSOI.type !== 'star') {
            const distToSOI = Vec2.distance(ship.position, currentSOI.position);
            if (distToSOI > currentSOI.soiRadius) {
                // Transition to parent
                ship.currentSOI = currentSOI.parent;
                this.game.showMessage('Leaving ' + currentSOI.name + ' SOI');
                return;
            }
        }
        
        // Check if we've entered a child's SOI
        const children = currentSOI.type === 'star' ? 
            Array.from(this.game.solarSystem.bodies.values()).filter(b => b.parent === currentSOI) :
            currentSOI.children;
            
        for (const child of children) {
            const distToChild = Vec2.distance(ship.position, child.position);
            if (distToChild < child.soiRadius) {
                ship.currentSOI = child;
                this.game.showMessage('Entering ' + child.name + ' SOI');
                return;
            }
        }
    }
    
    checkFloatingOrigin() {
        const ship = this.game.ship;
        const dist = ship.position.length();
        
        if (dist > PHYSICS_CONFIG.floatingOriginThreshold) {
            // Recenter universe
            const offset = ship.position.clone();
            
            ship.position = new Vec2(0, 0);
            ship.prevPosition = ship.prevPosition.sub(offset);
            
            // Offset all bodies
            for (const body of this.game.solarSystem.bodies.values()) {
                body.position = body.position.sub(offset);
            }
            
            // Offset asteroids
            for (const asteroid of this.game.solarSystem.asteroids) {
                asteroid.position = asteroid.position.sub(offset);
            }
            
            // Offset flags (they're relative to bodies, so no need)
            
            // Offset trail
            ship.trail = ship.trail.map(p => p.sub(offset));
            
            this.game.worldOffset = this.game.worldOffset.add(offset);
        }
    }
    
    updateLandedShip(dt) {
        const ship = this.game.ship;
        const body = ship.landedOn;
        
        if (!body) return;
        
        // Update position to stay on surface
        const angle = ship.landedAngle;
        const height = body.getTerrainHeight(angle);
        ship.position = body.position.add(Vec2.fromAngle(angle, height + 5));
        ship.velocity = body.velocity.clone();
        
        // Check for takeoff
        if (ship.throttle > 0.1 && ship.fuel > 0) {
            ship.isLanded = false;
            ship.landedOn = null;
            
            // Give initial upward velocity
            const upDir = Vec2.fromAngle(angle);
            ship.velocity = ship.velocity.add(upDir.mul(10));
            
            this.game.showMessage('LIFTOFF');
        }
    }
    
    getCCDCollision(p1, p2, body) {
        // Continuous collision detection using line-circle intersection
        const center = body.position;
        const d = p2.sub(p1);
        const f = p1.sub(center);
        
        // Quadratic coefficients
        const a = d.dot(d);
        const b = 2 * f.dot(d);
        const avgRadius = body.baseRadius;
        const c = f.dot(f) - avgRadius * avgRadius;
        
        const discriminant = b * b - 4 * a * c;
        
        if (discriminant >= 0) {
            const sqrtDisc = Math.sqrt(discriminant);
            const t1 = (-b - sqrtDisc) / (2 * a);
            const t2 = (-b + sqrtDisc) / (2 * a);
            
            if (t1 >= 0 && t1 <= 1) return t1;
            if (t2 >= 0 && t2 <= 1) return t2;
        }
        
        return null;
    }
}

/* ============================================================================
   SECTION 12: CAMERA SYSTEM
   ============================================================================ */

class Camera {
    constructor() {
        this.position = new Vec2(0, 0);
        this.targetPosition = new Vec2(0, 0);
        this.zoom = 1;
        this.targetZoom = 1;
        this.minZoom = 0.00001;
        this.maxZoom = 10;
        
        // Damping for smooth movement
        this.positionDamping = 0.05;
        this.zoomDamping = 0.1;
        
        // Look-ahead
        this.lookAheadFactor = 0.02;
        
        // Screen shake
        this.shakeIntensity = 0;
        this.shakeDecay = 0.9;
        this.shakeOffset = new Vec2(0, 0);
    }
    
    update(dt, ship, mode) {
        if (mode === 'manual') {
            // Follow ship with look-ahead
            const lookAhead = ship.velocity.mul(this.lookAheadFactor / this.zoom);
            this.targetPosition = ship.position.add(lookAhead);
        }
        
        // Smooth position interpolation
        this.position = this.position.lerp(this.targetPosition, this.positionDamping);
        
        // Smooth zoom interpolation
        this.zoom += (this.targetZoom - this.zoom) * this.zoomDamping;
        
        // Update screen shake
        if (this.shakeIntensity > 0.01) {
            this.shakeOffset = new Vec2(
                (Math.random() - 0.5) * this.shakeIntensity,
                (Math.random() - 0.5) * this.shakeIntensity
            );
            this.shakeIntensity *= this.shakeDecay;
        } else {
            this.shakeOffset = new Vec2(0, 0);
            this.shakeIntensity = 0;
        }
    }
    
    worldToScreen(worldPos, canvas) {
        const centered = worldPos.sub(this.position);
        const scaled = centered.mul(this.zoom);
        return new Vec2(
            canvas.width / 2 + scaled.x + this.shakeOffset.x,
            canvas.height / 2 - scaled.y + this.shakeOffset.y
        );
    }
    
    screenToWorld(screenPos, canvas) {
        const centered = new Vec2(
            screenPos.x - canvas.width / 2 - this.shakeOffset.x,
            -(screenPos.y - canvas.height / 2 - this.shakeOffset.y)
        );
        const scaled = centered.div(this.zoom);
        return scaled.add(this.position);
    }
    
    shake(intensity) {
        this.shakeIntensity = Math.max(this.shakeIntensity, intensity);
    }
    
    setZoom(zoom) {
        this.targetZoom = Math.max(this.minZoom, Math.min(this.maxZoom, zoom));
    }
    
    adjustZoom(factor) {
        this.setZoom(this.targetZoom * factor);
    }
    
    focusOn(position) {
        this.targetPosition = position.clone();
    }
    
    autoZoom(ship, soi) {
        if (soi) {
            const dist = Vec2.distance(ship.position, soi.position);
            const targetZoom = 500 / dist;
            this.setZoom(Math.max(0.001, Math.min(2, targetZoom)));
        }
    }
}

/* ============================================================================
   SECTION 13: RENDERER
   ============================================================================ */

class Renderer {
    constructor(canvas, game) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.game = game;
        
        // Pregenerate patterns
        this.patterns = {};
        this.createPatterns();
        
        // Star field (static background)
        this.starField = this.generateStarField();
    }
    
    createPatterns() {
        // Dotted pattern for rocky planets
        const dottedCanvas = document.createElement('canvas');
        dottedCanvas.width = 8;
        dottedCanvas.height = 8;
        const dottedCtx = dottedCanvas.getContext('2d');
        dottedCtx.fillStyle = '#666';
        dottedCtx.fillRect(0, 0, 8, 8);
        dottedCtx.fillStyle = '#555';
        dottedCtx.fillRect(2, 2, 2, 2);
        dottedCtx.fillRect(6, 6, 2, 2);
        this.patterns.dotted = this.ctx.createPattern(dottedCanvas, 'repeat');
        
        // Striped pattern for gas giants
        const stripedCanvas = document.createElement('canvas');
        stripedCanvas.width = 4;
        stripedCanvas.height = 20;
        const stripedCtx = stripedCanvas.getContext('2d');
        stripedCtx.fillStyle = '#887766';
        stripedCtx.fillRect(0, 0, 4, 20);
        stripedCtx.fillStyle = '#776655';
        stripedCtx.fillRect(0, 5, 4, 5);
        stripedCtx.fillStyle = '#998877';
        stripedCtx.fillRect(0, 15, 4, 5);
        this.patterns.striped = this.ctx.createPattern(stripedCanvas, 'repeat');
        
        // Crosshatch pattern for moons
        const crossCanvas = document.createElement('canvas');
        crossCanvas.width = 8;
        crossCanvas.height = 8;
        const crossCtx = crossCanvas.getContext('2d');
        crossCtx.fillStyle = '#555';
        crossCtx.fillRect(0, 0, 8, 8);
        crossCtx.strokeStyle = '#444';
        crossCtx.lineWidth = 1;
        crossCtx.beginPath();
        crossCtx.moveTo(0, 0);
        crossCtx.lineTo(8, 8);
        crossCtx.moveTo(8, 0);
        crossCtx.lineTo(0, 8);
        crossCtx.stroke();
        this.patterns.crosshatch = this.ctx.createPattern(crossCanvas, 'repeat');
    }
    
    generateStarField() {
        const stars = [];
        const rng = new SeededRandom('starfield');
        
        for (let i = 0; i < VISUAL_CONFIG.starFieldDensity; i++) {
            stars.push({
                x: rng.next(),
                y: rng.next(),
                brightness: rng.range(0.3, 1),
                size: rng.range(0.5, 2)
            });
        }
        
        return stars;
    }
    
    render() {
        const ctx = this.ctx;
        const canvas = this.canvas;
        const camera = this.game.camera;
        
        // Clear with black + noise
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Draw star field (parallax)
        this.drawStarField();
        
        // Draw grid
        if (this.game.mode === 'planned') {
            this.drawGrid();
        }
        
        // Draw celestial bodies in order
        this.drawSol();
        
        // Draw orbit lines first
        for (const body of this.game.solarSystem.bodies.values()) {
            if (body.type !== 'star') {
                this.drawOrbitLine(body);
            }
        }
        
        // Draw planets and moons
        for (const body of this.game.solarSystem.bodies.values()) {
            if (body.type !== 'star') {
                this.drawCelestialBody(body);
            }
        }
        
        // Draw asteroids
        this.drawAsteroids();
        
        // Draw flags
        this.drawFlags();
        
        // Draw ship orbit prediction
        if (this.game.mode === 'planned' || this.game.warpLevel > 0) {
            this.drawShipOrbit();
        }
        
        // Draw maneuver nodes
        this.drawManeuverNodes();
        
        // Draw ghost orbit for maneuver nodes
        this.drawGhostOrbit();
        
        // Draw ship trail
        this.drawShipTrail();
        
        // Draw ship
        this.drawShip();
        
        // Draw atmospheric effects
        this.drawAtmosphericEffects();
        
        // Draw target info
        if (this.game.target) {
            this.drawTargetIndicator();
        }
        
        // Draw closest approach marker
        this.drawClosestApproach();
        
        // Draw navball
        this.drawNavball();
    }
    
    drawStarField() {
        const ctx = this.ctx;
        const camera = this.game.camera;
        
        // Deep space static effect
        if (Math.random() < 0.01) {
            ctx.fillStyle = `rgba(255, 255, 255, ${Math.random() * 0.03})`;
            const x = Math.random() * this.canvas.width;
            const y = Math.random() * this.canvas.height;
            ctx.fillRect(x, y, 1, 1);
        }
        
        // Parallax stars
        const parallaxFactor = 0.0001;
        
        for (const star of this.starField) {
            const worldX = (star.x * 200000 - 100000) - camera.position.x * parallaxFactor;
            const worldY = (star.y * 200000 - 100000) - camera.position.y * parallaxFactor;
            
            // Wrap around
            let screenX = ((worldX % 200000) + 200000) % 200000 - 100000;
            let screenY = ((worldY % 200000) + 200000) % 200000 - 100000;
            
            const screenPos = camera.worldToScreen(new Vec2(screenX, screenY), this.canvas);
            
            if (screenPos.x >= 0 && screenPos.x < this.canvas.width &&
                screenPos.y >= 0 && screenPos.y < this.canvas.height) {
                ctx.fillStyle = `rgba(255, 255, 255, ${star.brightness})`;
                ctx.beginPath();
                ctx.arc(screenPos.x, screenPos.y, star.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }
    }
    
    drawGrid() {
        const ctx = this.ctx;
        const camera = this.game.camera;
        
        // Determine grid spacing based on zoom
        let spacing = VISUAL_CONFIG.gridSpacing;
        while (spacing * camera.zoom < 50) spacing *= 10;
        while (spacing * camera.zoom > 500) spacing /= 10;
        
        ctx.strokeStyle = VISUAL_CONFIG.gridColor;
        ctx.lineWidth = 1;
        
        // Calculate visible range
        const halfWidth = this.canvas.width / 2 / camera.zoom;
        const halfHeight = this.canvas.height / 2 / camera.zoom;
        
        const startX = Math.floor((camera.position.x - halfWidth) / spacing) * spacing;
        const endX = Math.ceil((camera.position.x + halfWidth) / spacing) * spacing;
        const startY = Math.floor((camera.position.y - halfHeight) / spacing) * spacing;
        const endY = Math.ceil((camera.position.y + halfHeight) / spacing) * spacing;
        
        ctx.beginPath();
        
        // Vertical lines
        for (let x = startX; x <= endX; x += spacing) {
            const screenStart = camera.worldToScreen(new Vec2(x, startY), this.canvas);
            const screenEnd = camera.worldToScreen(new Vec2(x, endY), this.canvas);
            ctx.moveTo(screenStart.x, screenStart.y);
            ctx.lineTo(screenEnd.x, screenEnd.y);
        }
        
        // Horizontal lines
        for (let y = startY; y <= endY; y += spacing) {
            const screenStart = camera.worldToScreen(new Vec2(startX, y), this.canvas);
            const screenEnd = camera.worldToScreen(new Vec2(endX, y), this.canvas);
            ctx.moveTo(screenStart.x, screenStart.y);
            ctx.lineTo(screenEnd.x, screenEnd.y);
        }
        
        ctx.stroke();
    }
    
    drawSol() {
        const ctx = this.ctx;
        const camera = this.game.camera;
        const sol = this.game.sol;
        
        const screenPos = camera.worldToScreen(sol.position, this.canvas);
        const screenRadius = sol.baseRadius * camera.zoom;
        
        if (screenRadius < 1) return;
        
        // Glow effect
        const glowRadius = screenRadius * 2;
        const gradient = ctx.createRadialGradient(
            screenPos.x, screenPos.y, screenRadius * 0.5,
            screenPos.x, screenPos.y, glowRadius
        );
        gradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
        gradient.addColorStop(0.5, 'rgba(255, 255, 200, 0.3)');
        gradient.addColorStop(1, 'rgba(255, 255, 200, 0)');
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(screenPos.x, screenPos.y, glowRadius, 0, Math.PI * 2);
        ctx.fill();
        
        // Main body with wobble effect
        ctx.save();
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        
        const time = this.game.gameTime * 0.001;
        const wobbleSegments = 64;
        
        for (let i = 0; i <= wobbleSegments; i++) {
            const theta = (i / wobbleSegments) * Math.PI * 2;
            const wobble = Math.sin(4 * theta + time) * screenRadius * 0.02 +
                          Math.sin(7 * theta + time * 1.5) * screenRadius * 0.01;
            const r = screenRadius + wobble;
            const x = screenPos.x + Math.cos(theta) * r;
            const y = screenPos.y + Math.sin(theta) * r;
            
            if (i === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        }
        
        ctx.closePath();
        ctx.fill();
        
        // Corona lines
        ctx.strokeStyle = 'rgba(255, 255, 200, 0.3)';
        ctx.lineWidth = 1;
        
        for (let i = 0; i < 24; i++) {
            const angle = (i / 24) * Math.PI * 2 + time * 0.1;
            const innerR = screenRadius * 1.1;
            const outerR = screenRadius * (1.3 + Math.sin(angle * 3 + time) * 0.2);
            
            ctx.beginPath();
            ctx.moveTo(
                screenPos.x + Math.cos(angle) * innerR,
                screenPos.y + Math.sin(angle) * innerR
            );
            ctx.lineTo(
                screenPos.x + Math.cos(angle) * outerR,
                screenPos.y + Math.sin(angle) * outerR
            );
            ctx.stroke();
        }
        
        ctx.restore();
    }
    
    drawCelestialBody(body) {
        const ctx = this.ctx;
        const camera = this.game.camera;
        
        const screenPos = camera.worldToScreen(body.position, this.canvas);
        const screenRadius = body.baseRadius * camera.zoom;
        
        // Skip if too small or off-screen
        if (screenRadius < 0.5) return;
        if (screenPos.x < -screenRadius * 2 || screenPos.x > this.canvas.width + screenRadius * 2) return;
        if (screenPos.y < -screenRadius * 2 || screenPos.y > this.canvas.height + screenRadius * 2) return;
        
        ctx.save();
        
        // Draw rings first (behind planet)
        if (body.ringInner > 0 && body.ringOuter > 0) {
            this.drawRings(body, screenPos, camera.zoom);
        }
        
        // Draw atmosphere (behind body)
        if (body.hasAtmosphere) {
            this.drawAtmosphere(body, screenPos, camera.zoom);
        }
        
        // Draw the terrain
        if (body.terrain && screenRadius > 5) {
            this.drawTerrain(body, screenPos, camera.zoom);
        } else {
            // Simple circle for distant bodies
            ctx.fillStyle = body.color;
            ctx.beginPath();
            ctx.arc(screenPos.x, screenPos.y, Math.max(2, screenRadius), 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Draw SOI boundary in planned mode
        if (this.game.mode === 'planned' && body.soiRadius < Infinity) {
            const soiScreenRadius = body.soiRadius * camera.zoom;
            if (soiScreenRadius > 10 && soiScreenRadius < 10000) {
                ctx.strokeStyle = 'rgba(100, 100, 100, 0.3)';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.arc(screenPos.x, screenPos.y, soiScreenRadius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }
        
        // Label
        if (screenRadius > 3) {
            ctx.fillStyle = '#888';
            ctx.font = '10px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(body.name, screenPos.x, screenPos.y - screenRadius - 10);
        }
        
        ctx.restore();
    }
    
    drawTerrain(body, screenPos, zoom) {
        const ctx = this.ctx;
        const points = body.terrain.getPoints();
        
        ctx.save();
        ctx.translate(screenPos.x, screenPos.y);
        ctx.rotate(-body.rotationAngle);
        
        // Get pattern
        let fillStyle = body.color;
        if (this.patterns[body.pattern]) {
            fillStyle = this.patterns[body.pattern];
        }
        
        ctx.fillStyle = fillStyle;
        ctx.strokeStyle = '#999';
        ctx.lineWidth = 1;
        
        ctx.beginPath();
        
        for (let i = 0; i < points.length; i++) {
            const p = points[i];
            const x = p.x * zoom;
            const y = -p.y * zoom; // Flip Y for screen
            
            if (i === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        }
        
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        
        ctx.restore();
    }
    
    drawAtmosphere(body, screenPos, zoom) {
        const ctx = this.ctx;
        const innerRadius = body.baseRadius * zoom;
        const outerRadius = (body.baseRadius + body.atmosphereHeight) * zoom;
        
        if (outerRadius < 5) return;
        
        const gradient = ctx.createRadialGradient(
            screenPos.x, screenPos.y, innerRadius,
            screenPos.x, screenPos.y, outerRadius
        );
        
        gradient.addColorStop(0, 'rgba(180, 180, 200, 0.4)');
        gradient.addColorStop(0.5, 'rgba(150, 150, 180, 0.2)');
        gradient.addColorStop(1, 'rgba(150, 150, 180, 0)');
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(screenPos.x, screenPos.y, outerRadius, 0, Math.PI * 2);
        ctx.fill();
    }
    
    drawRings(body, screenPos, zoom) {
        const ctx = this.ctx;
        const innerRadius = body.ringInner * zoom;
        const outerRadius = body.ringOuter * zoom;
        
        if (outerRadius < 5) return;
        
        const gradient = ctx.createRadialGradient(
            screenPos.x, screenPos.y, innerRadius,
            screenPos.x, screenPos.y, outerRadius
        );
        
        gradient.addColorStop(0, 'rgba(150, 140, 130, 0)');
        gradient.addColorStop(0.1, 'rgba(150, 140, 130, 0.5)');
        gradient.addColorStop(0.3, 'rgba(130, 120, 110, 0.3)');
        gradient.addColorStop(0.5, 'rgba(150, 140, 130, 0.4)');
        gradient.addColorStop(0.7, 'rgba(130, 120, 110, 0.3)');
        gradient.addColorStop(0.9, 'rgba(150, 140, 130, 0.2)');
        gradient.addColorStop(1, 'rgba(150, 140, 130, 0)');
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(screenPos.x, screenPos.y, outerRadius, 0, Math.PI * 2);
        ctx.arc(screenPos.x, screenPos.y, innerRadius, 0, Math.PI * 2, true);
        ctx.fill();
    }
    
    drawOrbitLine(body) {
        const ctx = this.ctx;
        const camera = this.game.camera;
        
        if (!body.parent) return;
        
        const parentScreenPos = camera.worldToScreen(body.parent.position, this.canvas);
        const points = OrbitalMechanics.getOrbitPoints(body.semiMajorAxis, body.eccentricity, body.argumentOfPeriapsis);
        
        ctx.save();
        ctx.strokeStyle = 'rgba(100, 100, 100, 0.4)';
        ctx.lineWidth = 1;
        ctx.setLineDash([3, 3]);
        
        ctx.beginPath();
        
        for (let i = 0; i < points.length; i++) {
            const worldPos = body.parent.position.add(points[i]);
            const screenPos = camera.worldToScreen(worldPos, this.canvas);
            
            if (i === 0) {
                ctx.moveTo(screenPos.x, screenPos.y);
            } else {
                ctx.lineTo(screenPos.x, screenPos.y);
            }
        }
        
        ctx.closePath();
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.restore();
    }
    
    drawAsteroids() {
        const ctx = this.ctx;
        const camera = this.game.camera;
        const ship = this.game.ship;
        
        // Only draw nearby asteroids
        const nearAsteroids = this.game.solarSystem.getNearestAsteroids(ship.position, 50);
        
        for (const asteroid of nearAsteroids) {
            const screenPos = camera.worldToScreen(asteroid.position, this.canvas);
            const screenRadius = asteroid.radius * camera.zoom;
            
            if (screenRadius < 0.5) continue;
            if (screenPos.x < -50 || screenPos.x > this.canvas.width + 50) continue;
            if (screenPos.y < -50 || screenPos.y > this.canvas.height + 50) continue;
            
            ctx.save();
            ctx.translate(screenPos.x, screenPos.y);
            ctx.rotate(asteroid.rotationAngle);
            
            // Draw irregular asteroid shape
            ctx.fillStyle = '#555';
            ctx.strokeStyle = '#777';
            ctx.lineWidth = 1;
            
            ctx.beginPath();
            const rng = new SeededRandom(asteroid.id);
            const numVertices = 8;
            
            for (let i = 0; i < numVertices; i++) {
                const angle = (i / numVertices) * Math.PI * 2;
                const r = screenRadius * (0.7 + rng.next() * 0.3);
                const x = Math.cos(angle) * r;
                const y = Math.sin(angle) * r;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            ctx.restore();
        }
    }
    
    drawShipOrbit() {
        const ctx = this.ctx;
        const camera = this.game.camera;
        const ship = this.game.ship;
        const soi = ship.currentSOI || this.game.sol;
        
        if (ship.isLanded) return;
        
        const relPos = ship.position.sub(soi.position);
        const elements = OrbitalMechanics.stateToOrbital(relPos, ship.velocity, soi.mu);
        
        const points = OrbitalMechanics.getOrbitPoints(elements.a, elements.e, elements.omega);
        
        // Determine orbit color based on eccentricity
        let strokeStyle = 'rgba(200, 200, 200, 0.8)';
        if (elements.e >= 1) {
            strokeStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.setLineDash([5, 5]);
        }
        
        ctx.save();
        ctx.strokeStyle = strokeStyle;
        ctx.lineWidth = 2;
        
        ctx.beginPath();
        
        for (let i = 0; i < points.length; i++) {
            const worldPos = soi.position.add(points[i]);
            const screenPos = camera.worldToScreen(worldPos, this.canvas);
            
            if (i === 0) {
                ctx.moveTo(screenPos.x, screenPos.y);
            } else {
                ctx.lineTo(screenPos.x, screenPos.y);
            }
        }
        
        if (elements.e < 1) {
            ctx.closePath();
        }
        
        ctx.stroke();
        ctx.setLineDash([]);
        
        // Draw apoapsis and periapsis markers
        if (elements.a > 0 && elements.e < 1) {
            // Periapsis
            const pePos = OrbitalMechanics.orbitalToPosition(elements.a, elements.e, elements.omega, 0);
            const peScreen = camera.worldToScreen(soi.position.add(pePos), this.canvas);
            
            ctx.fillStyle = '#aaa';
            ctx.beginPath();
            ctx.arc(peScreen.x, peScreen.y, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#888';
            ctx.font = '10px monospace';
            ctx.fillText('PE', peScreen.x + 10, peScreen.y);
            
            // Apoapsis
            const apPos = OrbitalMechanics.orbitalToPosition(elements.a, elements.e, elements.omega, Math.PI);
            const apScreen = camera.worldToScreen(soi.position.add(apPos), this.canvas);
            
            ctx.fillStyle = '#aaa';
            ctx.beginPath();
            ctx.arc(apScreen.x, apScreen.y, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#888';
            ctx.fillText('AP', apScreen.x + 10, apScreen.y);
        }
        
        ctx.restore();
    }
    
    drawManeuverNodes() {
        const ctx = this.ctx;
        const camera = this.game.camera;
        
        for (const node of this.game.maneuverNodes) {
            const screenPos = camera.worldToScreen(node.position, this.canvas);
            
            // Draw node marker
            ctx.save();
            ctx.translate(screenPos.x, screenPos.y);
            
            // Outer ring
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 0, 15, 0, Math.PI * 2);
            ctx.stroke();
            
            // Inner dot
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(0, 0, 5, 0, Math.PI * 2);
            ctx.fill();
            
            // Delta-V direction arrow
            if (node.deltaV.length() > 0) {
                const dvDir = node.deltaV.normalize();
                const arrowLength = 30;
                
                ctx.strokeStyle = '#aaa';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(dvDir.x * arrowLength, -dvDir.y * arrowLength);
                ctx.stroke();
            }
            
            ctx.restore();
        }
    }
    
    drawShipTrail() {
        const ctx = this.ctx;
        const camera = this.game.camera;
        const trail = this.game.ship.trail;
        
        if (trail.length < 2) return;
        
        ctx.save();
        ctx.strokeStyle = 'rgba(150, 150, 150, 0.5)';
        ctx.lineWidth = 1;
        
        ctx.beginPath();
        
        for (let i = 0; i < trail.length; i++) {
            const screenPos = camera.worldToScreen(trail[i], this.canvas);
            
            if (i === 0) {
                ctx.moveTo(screenPos.x, screenPos.y);
            } else {
                ctx.lineTo(screenPos.x, screenPos.y);
            }
        }
        
        ctx.stroke();
        ctx.restore();
    }
    
    drawShip() {
        const ctx = this.ctx;
        const camera = this.game.camera;
        const ship = this.game.ship;
        
        const screenPos = camera.worldToScreen(ship.position, this.canvas);
        const size = Math.max(5, SHIP_CONFIG.size * camera.zoom);
        
        ctx.save();
        ctx.translate(screenPos.x, screenPos.y);
        ctx.rotate(-ship.angle + Math.PI / 2);
        
        // Engine glow when thrusting
        if (ship.throttle > 0 && ship.fuel > 0 && !ship.isLanded) {
            const glowIntensity = ship.throttle;
            const glowLength = size * (1 + glowIntensity * 2);
            
            // Engine flame
            ctx.fillStyle = `rgba(255, 255, 255, ${glowIntensity * 0.8})`;
            ctx.beginPath();
            ctx.moveTo(-size * 0.3, size * 0.5);
            ctx.lineTo(size * 0.3, size * 0.5);
            ctx.lineTo(0, size * 0.5 + glowLength);
            ctx.closePath();
            ctx.fill();
            
            // Exhaust particles
            for (let i = 0; i < 3; i++) {
                const particleY = size * 0.5 + glowLength * (0.5 + Math.random() * 0.5);
                const particleX = (Math.random() - 0.5) * size * 0.5;
                const particleSize = 2 + Math.random() * 3;
                
                ctx.fillStyle = `rgba(200, 200, 200, ${0.5 * (1 - particleY / (size * 3))})`;
                ctx.beginPath();
                ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // RCS particles
        const rcsSize = 2;
        const rcsOffset = size * 0.4;
        
        if (ship.input.rotateLeft) {
            ctx.fillStyle = 'rgba(200, 200, 200, 0.7)';
            ctx.beginPath();
            ctx.arc(rcsOffset, -size * 0.3, rcsSize, 0, Math.PI * 2);
            ctx.arc(-rcsOffset, size * 0.3, rcsSize, 0, Math.PI * 2);
            ctx.fill();
        }
        if (ship.input.rotateRight) {
            ctx.fillStyle = 'rgba(200, 200, 200, 0.7)';
            ctx.beginPath();
            ctx.arc(-rcsOffset, -size * 0.3, rcsSize, 0, Math.PI * 2);
            ctx.arc(rcsOffset, size * 0.3, rcsSize, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Ship body
        ctx.fillStyle = '#ccc';
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 1;
        
        // Main body (triangle)
        ctx.beginPath();
        ctx.moveTo(0, -size);
        ctx.lineTo(-size * 0.5, size * 0.5);
        ctx.lineTo(size * 0.5, size * 0.5);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        
        // Landing gear indicators
        ctx.fillStyle = '#888';
        ctx.fillRect(-size * 0.4, size * 0.4, size * 0.15, size * 0.2);
        ctx.fillRect(size * 0.25, size * 0.4, size * 0.15, size * 0.2);
        
        ctx.restore();
        
        // Draw velocity vector in planned mode
        if (this.game.mode === 'planned') {
            const velDir = ship.velocity.normalize();
            const velMag = ship.velocity.length();
            const arrowLength = Math.min(100, 20 + velMag * 0.01);
            
            ctx.save();
            ctx.strokeStyle = '#88ff88';
            ctx.lineWidth = 2;
            
            const endPos = new Vec2(
                screenPos.x + velDir.x * arrowLength,
                screenPos.y - velDir.y * arrowLength
            );
            
            ctx.beginPath();
            ctx.moveTo(screenPos.x, screenPos.y);
            ctx.lineTo(endPos.x, endPos.y);
            ctx.stroke();
            
            // Arrow head
            const headSize = 8;
            const headAngle = Math.atan2(-velDir.y, velDir.x);
            
            ctx.beginPath();
            ctx.moveTo(endPos.x, endPos.y);
            ctx.lineTo(
                endPos.x - Math.cos(headAngle - 0.3) * headSize,
                endPos.y + Math.sin(headAngle - 0.3) * headSize
            );
            ctx.moveTo(endPos.x, endPos.y);
            ctx.lineTo(
                endPos.x - Math.cos(headAngle + 0.3) * headSize,
                endPos.y + Math.sin(headAngle + 0.3) * headSize
            );
            ctx.stroke();
            
            ctx.restore();
        }
    }
    
    drawAtmosphericEffects() {
        const ctx = this.ctx;
        const ship = this.game.ship;
        const camera = this.game.camera;
        
        if (!ship.currentSOI || !ship.currentSOI.hasAtmosphere) return;
        
        const relPos = ship.position.sub(ship.currentSOI.position);
        const altitude = relPos.length() - ship.currentSOI.baseRadius;
        
        if (altitude > ship.currentSOI.atmosphereHeight) return;
        
        const density = ship.currentSOI.getAtmosphericDensity(altitude);
        const speed = ship.velocity.length();
        
        // Wind streaks
        if (speed > 100 && density > 0.01) {
            const screenPos = camera.worldToScreen(ship.position, this.canvas);
            const velDir = ship.velocity.normalize();
            const streakCount = Math.min(20, Math.floor(speed / 50));
            
            ctx.save();
            ctx.strokeStyle = `rgba(200, 200, 200, ${Math.min(0.5, density * speed / 1000)})`;
            ctx.lineWidth = 1;
            
            for (let i = 0; i < streakCount; i++) {
                const offset = new Vec2(
                    (Math.random() - 0.5) * 100,
                    (Math.random() - 0.5) * 100
                );
                const start = screenPos.add(offset);
                const length = 20 + Math.random() * 30;
                const end = new Vec2(
                    start.x + velDir.x * length,
                    start.y - velDir.y * length
                );
                
                ctx.beginPath();
                ctx.moveTo(start.x, start.y);
                ctx.lineTo(end.x, end.y);
                ctx.stroke();
            }
            
            ctx.restore();
        }
        
        // Bow shock for supersonic speeds
        if (speed > 500 && density > 0.05) {
            const screenPos = camera.worldToScreen(ship.position, this.canvas);
            const velAngle = ship.velocity.angle();
            
            ctx.save();
            ctx.translate(screenPos.x, screenPos.y);
            ctx.rotate(-velAngle + Math.PI);
            
            const shockIntensity = Math.min(1, (speed - 500) / 2000);
            ctx.strokeStyle = `rgba(255, 200, 150, ${shockIntensity * 0.8})`;
            ctx.lineWidth = 3;
            
            ctx.beginPath();
            ctx.arc(0, 0, 30, -Math.PI * 0.3, Math.PI * 0.3);
            ctx.stroke();
            
            ctx.restore();
        }
    }
    
    drawFlags() {
        const ctx = this.ctx;
        const camera = this.game.camera;
        
        for (const flag of this.game.flags) {
            const body = this.game.solarSystem.bodies.get(flag.bodyId);
            if (!body) continue;
            
            const surfaceHeight = body.getTerrainHeight(flag.angle);
            const flagPos = body.position.add(Vec2.fromAngle(flag.angle, surfaceHeight));
            const screenPos = camera.worldToScreen(flagPos, this.canvas);
            
            // Flag pole
            ctx.save();
            ctx.translate(screenPos.x, screenPos.y);
            ctx.rotate(-flag.angle + Math.PI / 2);
            
            ctx.strokeStyle = '#aaa';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(0, -20);
            ctx.stroke();
            
            // Flag
            ctx.fillStyle = '#888';
            ctx.fillRect(0, -20, 10, 7);
            
            ctx.restore();
            
            // Label
            ctx.fillStyle = '#666';
            ctx.font = '9px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(flag.label, screenPos.x, screenPos.y - 25);
        }
    }
    
    drawTargetIndicator() {
        const ctx = this.ctx;
        const camera = this.game.camera;
        const target = this.game.target;
        
        const screenPos = camera.worldToScreen(target.position, this.canvas);
        
        // Target brackets
        ctx.save();
        ctx.strokeStyle = '#aaa';
        ctx.lineWidth = 2;
        
        const bracketSize = 20;
        
        // Top-left
        ctx.beginPath();
        ctx.moveTo(screenPos.x - bracketSize, screenPos.y - bracketSize + 5);
        ctx.lineTo(screenPos.x - bracketSize, screenPos.y - bracketSize);
        ctx.lineTo(screenPos.x - bracketSize + 5, screenPos.y - bracketSize);
        ctx.stroke();
        
        // Top-right
        ctx.beginPath();
        ctx.moveTo(screenPos.x + bracketSize, screenPos.y - bracketSize + 5);
        ctx.lineTo(screenPos.x + bracketSize, screenPos.y - bracketSize);
        ctx.lineTo(screenPos.x + bracketSize - 5, screenPos.y - bracketSize);
        ctx.stroke();
        
        // Bottom-left
        ctx.beginPath();
        ctx.moveTo(screenPos.x - bracketSize, screenPos.y + bracketSize - 5);
        ctx.lineTo(screenPos.x - bracketSize, screenPos.y + bracketSize);
        ctx.lineTo(screenPos.x - bracketSize + 5, screenPos.y + bracketSize);
        ctx.stroke();
        
        // Bottom-right
        ctx.beginPath();
        ctx.moveTo(screenPos.x + bracketSize, screenPos.y + bracketSize - 5);
        ctx.lineTo(screenPos.x + bracketSize, screenPos.y + bracketSize);
        ctx.lineTo(screenPos.x + bracketSize - 5, screenPos.y + bracketSize);
        ctx.stroke();
        
        ctx.restore();
    }
    
    drawClosestApproach() {
        const ctx = this.ctx;
        const camera = this.game.camera;
        const ship = this.game.ship;
        const target = this.game.target;
        
        if (!target || ship.isLanded) return;
        
        // Find closest approach between ship and target orbits
        const soi = ship.currentSOI || this.game.sol;
        const relPos = ship.position.sub(soi.position);
        const elements = OrbitalMechanics.stateToOrbital(relPos, ship.velocity, soi.mu);
        
        if (elements.e >= 1 || elements.a <= 0) return;
        
        // Sample points on ship's orbit to find closest approach to target
        let minDist = Infinity;
        let closestShipPos = null;
        let closestTargetPos = null;
        
        const numSamples = 72;
        const totalTime = elements.period;
        
        for (let i = 0; i < numSamples; i++) {
            const t = (i / numSamples) * totalTime;
            const result = OrbitalMechanics.propagateOrbit(elements, soi.mu, t);
            const shipPos = soi.position.add(result.position);
            
            // Propagate target if it has an orbit
            let targetPos = target.position;
            if (target.parent) {
                const targetElements = {
                    a: target.semiMajorAxis,
                    e: target.eccentricity,
                    omega: target.argumentOfPeriapsis,
                    nu: target.trueAnomaly
                };
                const targetResult = OrbitalMechanics.propagateOrbit(targetElements, target.parent.mu, t);
                targetPos = target.parent.position.add(targetResult.position);
            }
            
            const dist = Vec2.distance(shipPos, targetPos);
            if (dist < minDist) {
                minDist = dist;
                closestShipPos = shipPos;
                closestTargetPos = targetPos;
            }
        }
        
        if (closestShipPos && minDist < target.soiRadius * 5) {
            // Draw closest approach markers
            const shipScreenPos = camera.worldToScreen(closestShipPos, this.canvas);
            const targetScreenPos = camera.worldToScreen(closestTargetPos, this.canvas);
            
            ctx.save();
            ctx.setLineDash([3, 3]);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 1;
            
            // Line connecting closest approach points
            ctx.beginPath();
            ctx.moveTo(shipScreenPos.x, shipScreenPos.y);
            ctx.lineTo(targetScreenPos.x, targetScreenPos.y);
            ctx.stroke();
            
            ctx.setLineDash([]);
            
            // Ship closest approach marker (arrow pointing inward)
            ctx.strokeStyle = '#aaa';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(shipScreenPos.x, shipScreenPos.y, 8, 0, Math.PI * 2);
            ctx.stroke();
            
            // Target closest approach marker
            ctx.beginPath();
            ctx.arc(targetScreenPos.x, targetScreenPos.y, 8, 0, Math.PI * 2);
            ctx.stroke();
            
            // Distance label
            ctx.fillStyle = '#888';
            ctx.font = '10px monospace';
            ctx.textAlign = 'center';
            const midX = (shipScreenPos.x + targetScreenPos.x) / 2;
            const midY = (shipScreenPos.y + targetScreenPos.y) / 2;
            ctx.fillText(this.game.ui.formatDistance(minDist), midX, midY - 5);
            
            ctx.restore();
        }
    }
    
    drawGhostOrbit() {
        const ctx = this.ctx;
        const camera = this.game.camera;
        const ship = this.game.ship;
        
        // Draw ghost orbit for maneuver nodes
        for (const node of this.game.maneuverNodes) {
            if (node.executed || node.deltaV.length() < 0.1) continue;
            
            const soi = ship.currentSOI || this.game.sol;
            
            // Calculate post-burn velocity
            const relPos = node.position.sub(soi.position);
            const currentVel = ship.velocity.clone(); // Simplified - should calculate velocity at node
            const postBurnVel = currentVel.add(node.deltaV);
            
            // Get post-burn orbital elements
            const elements = OrbitalMechanics.stateToOrbital(relPos, postBurnVel, soi.mu);
            
            // Draw ghost orbit
            const points = OrbitalMechanics.getOrbitPoints(elements.a, elements.e, elements.omega);
            
            ctx.save();
            ctx.strokeStyle = 'rgba(100, 200, 255, 0.6)';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            
            ctx.beginPath();
            
            for (let i = 0; i < points.length; i++) {
                const worldPos = soi.position.add(points[i]);
                const screenPos = camera.worldToScreen(worldPos, this.canvas);
                
                if (i === 0) {
                    ctx.moveTo(screenPos.x, screenPos.y);
                } else {
                    ctx.lineTo(screenPos.x, screenPos.y);
                }
            }
            
            if (elements.e < 1) {
                ctx.closePath();
            }
            
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw new AP/PE markers
            if (elements.a > 0 && elements.e < 1) {
                // New Periapsis
                const pePos = OrbitalMechanics.orbitalToPosition(elements.a, elements.e, elements.omega, 0);
                const peScreen = camera.worldToScreen(soi.position.add(pePos), this.canvas);
                
                ctx.fillStyle = 'rgba(100, 200, 255, 0.8)';
                ctx.beginPath();
                ctx.arc(peScreen.x, peScreen.y, 4, 0, Math.PI * 2);
                ctx.fill();
                
                // New Apoapsis
                const apPos = OrbitalMechanics.orbitalToPosition(elements.a, elements.e, elements.omega, Math.PI);
                const apScreen = camera.worldToScreen(soi.position.add(apPos), this.canvas);
                
                ctx.beginPath();
                ctx.arc(apScreen.x, apScreen.y, 4, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.restore();
        }
    }
    
    drawNavball() {
        const ctx = this.ctx;
        const ship = this.game.ship;
        const container = document.getElementById('navball-container');
        
        if (!container) return;
        
        // Create navball canvas if it doesn't exist
        let navCanvas = container.querySelector('canvas');
        if (!navCanvas) {
            navCanvas = document.createElement('canvas');
            navCanvas.width = 180;
            navCanvas.height = 180;
            container.appendChild(navCanvas);
        }
        
        const nctx = navCanvas.getContext('2d');
        const cx = 90;
        const cy = 90;
        const radius = 80;
        
        // Clear
        nctx.clearRect(0, 0, 180, 180);
        
        // Outer ring
        nctx.strokeStyle = '#555';
        nctx.lineWidth = 3;
        nctx.beginPath();
        nctx.arc(cx, cy, radius, 0, Math.PI * 2);
        nctx.stroke();
        
        // Inner rotating part
        nctx.save();
        nctx.translate(cx, cy);
        nctx.rotate(ship.angle);
        
        // Horizon line
        nctx.strokeStyle = '#666';
        nctx.lineWidth = 2;
        nctx.beginPath();
        nctx.moveTo(-radius + 10, 0);
        nctx.lineTo(radius - 10, 0);
        nctx.stroke();
        
        // Pitch ladder
        nctx.strokeStyle = '#444';
        nctx.lineWidth = 1;
        for (let deg = -60; deg <= 60; deg += 30) {
            if (deg === 0) continue;
            const y = deg * 0.8;
            const halfWidth = 20 - Math.abs(deg) / 4;
            nctx.beginPath();
            nctx.moveTo(-halfWidth, y);
            nctx.lineTo(halfWidth, y);
            nctx.stroke();
        }
        
        nctx.restore();
        
        // Fixed ship indicator
        nctx.strokeStyle = '#fff';
        nctx.lineWidth = 2;
        nctx.beginPath();
        nctx.moveTo(cx, cy - 15);
        nctx.lineTo(cx - 10, cy + 5);
        nctx.lineTo(cx, cy);
        nctx.lineTo(cx + 10, cy + 5);
        nctx.lineTo(cx, cy - 15);
        nctx.stroke();
        
        // Prograde marker
        const prograde = ship.velocity.normalize();
        const progradeAngle = -prograde.angle() + Math.PI / 2;
        const markerDist = 50;
        
        nctx.save();
        nctx.translate(cx, cy);
        nctx.rotate(progradeAngle + ship.angle);
        
        nctx.strokeStyle = '#8f8';
        nctx.lineWidth = 2;
        nctx.beginPath();
        nctx.arc(0, -markerDist, 8, 0, Math.PI * 2);
        nctx.stroke();
        nctx.beginPath();
        nctx.moveTo(0, -markerDist - 12);
        nctx.lineTo(0, -markerDist - 8);
        nctx.moveTo(0, -markerDist + 12);
        nctx.lineTo(0, -markerDist + 8);
        nctx.moveTo(-12, -markerDist);
        nctx.lineTo(-8, -markerDist);
        nctx.moveTo(12, -markerDist);
        nctx.lineTo(8, -markerDist);
        nctx.stroke();
        
        nctx.restore();
        
        // Retrograde marker
        nctx.save();
        nctx.translate(cx, cy);
        nctx.rotate(progradeAngle + Math.PI + ship.angle);
        
        nctx.strokeStyle = '#f88';
        nctx.lineWidth = 2;
        nctx.beginPath();
        nctx.arc(0, -markerDist, 8, 0, Math.PI * 2);
        nctx.stroke();
        nctx.beginPath();
        nctx.moveTo(-6, -markerDist - 6);
        nctx.lineTo(6, -markerDist + 6);
        nctx.moveTo(6, -markerDist - 6);
        nctx.lineTo(-6, -markerDist + 6);
        nctx.stroke();
        
        nctx.restore();
        
        // Heading text
        let heading = ((-ship.angle * 180 / Math.PI) % 360 + 360) % 360;
        nctx.fillStyle = '#888';
        nctx.font = '12px monospace';
        nctx.textAlign = 'center';
        nctx.fillText(Math.round(heading) + '°', cx, cy + radius + 15);
    }
}

/* ============================================================================
   SECTION 14: INPUT HANDLER
   ============================================================================ */

class InputHandler {
    constructor(game) {
        this.game = game;
        this.mousePosition = new Vec2(0, 0);
        this.mouseDown = false;
        this.rightMouseDown = false;
        this.dragStart = null;
        this.selectedNode = null;
        
        this.setupKeyboardListeners();
        this.setupMouseListeners();
    }
    
    setupKeyboardListeners() {
        window.addEventListener('keydown', (e) => this.handleKeyDown(e));
        window.addEventListener('keyup', (e) => this.handleKeyUp(e));
    }
    
    setupMouseListeners() {
        const canvas = this.game.canvas;
        
        canvas.addEventListener('mousemove', (e) => {
            this.mousePosition = new Vec2(e.clientX, e.clientY);
            this.handleMouseMove(e);
        });
        
        canvas.addEventListener('mousedown', (e) => {
            if (e.button === 0) {
                this.mouseDown = true;
                this.handleLeftClick(e);
            } else if (e.button === 2) {
                this.rightMouseDown = true;
                this.dragStart = new Vec2(e.clientX, e.clientY);
            }
        });
        
        canvas.addEventListener('mouseup', (e) => {
            if (e.button === 0) {
                this.mouseDown = false;
                this.handleLeftRelease(e);
            } else if (e.button === 2) {
                this.rightMouseDown = false;
                this.dragStart = null;
            }
        });
        
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
            this.game.camera.adjustZoom(zoomFactor);
        });
        
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });
    }
    
    handleKeyDown(e) {
        const ship = this.game.ship;
        
        switch(e.key.toLowerCase()) {
            // Movement
            case 'w':
                ship.input.forward = true;
                break;
            case 's':
                ship.input.backward = true;
                break;
            case 'a':
                ship.input.left = true;
                break;
            case 'd':
                ship.input.right = true;
                break;
            case 'q':
                ship.input.rotateLeft = true;
                break;
            case 'e':
                ship.input.rotateRight = true;
                break;
                
            // Throttle
            case 'shift':
                ship.input.throttleUp = true;
                break;
            case 'control':
                ship.input.throttleDown = true;
                break;
            case 'z':
                ship.throttle = 1;
                break;
            case 'x':
                ship.throttle = 0;
                break;
                
            // Time warp
            case ',':
            case '[':
                this.game.decreaseWarp();
                break;
            case '.':
            case ']':
                this.game.increaseWarp();
                break;
            case ' ':
                this.game.warpLevel = 0;
                this.game.showMessage('WARP STOPPED');
                e.preventDefault();
                break;
                
            // Mode toggle
            case 'm':
                this.game.toggleMode();
                break;
                
            // Target
            case 't':
                this.game.cycleTarget();
                break;
                
            // Plant flag
            case 'f':
                if (ship.isLanded) {
                    this.game.plantFlag();
                }
                break;
                
            // Reset (for testing)
            case 'r':
                if (e.ctrlKey) {
                    this.game.resetShip();
                }
                break;
        }
    }
    
    handleKeyUp(e) {
        const ship = this.game.ship;
        
        switch(e.key.toLowerCase()) {
            case 'w':
                ship.input.forward = false;
                break;
            case 's':
                ship.input.backward = false;
                break;
            case 'a':
                ship.input.left = false;
                break;
            case 'd':
                ship.input.right = false;
                break;
            case 'q':
                ship.input.rotateLeft = false;
                break;
            case 'e':
                ship.input.rotateRight = false;
                break;
            case 'shift':
                ship.input.throttleUp = false;
                break;
            case 'control':
                ship.input.throttleDown = false;
                break;
        }
    }
    
    handleMouseMove(e) {
        if (this.rightMouseDown && this.dragStart) {
            // Pan camera
            const dx = e.clientX - this.dragStart.x;
            const dy = e.clientY - this.dragStart.y;
            
            const worldDelta = new Vec2(
                -dx / this.game.camera.zoom,
                dy / this.game.camera.zoom
            );
            
            this.game.camera.targetPosition = this.game.camera.targetPosition.add(worldDelta);
            this.dragStart = new Vec2(e.clientX, e.clientY);
        }
        
        // Handle maneuver node dragging
        if (this.selectedNode && this.mouseDown) {
            this.updateManeuverNode(e);
        }
    }
    
    handleLeftClick(e) {
        const worldPos = this.game.camera.screenToWorld(
            new Vec2(e.clientX, e.clientY),
            this.game.canvas
        );
        
        if (this.game.mode === 'planned') {
            // Check if clicking on existing node
            for (const node of this.game.maneuverNodes) {
                const nodeDist = Vec2.distance(worldPos, node.position);
                if (nodeDist < 500 / this.game.camera.zoom) {
                    this.selectedNode = node;
                    return;
                }
            }
            
            // Check if clicking on orbit line to create new node
            if (this.isNearOrbitLine(worldPos)) {
                this.createManeuverNode(worldPos);
            }
            
            // Check if clicking on a body to target
            for (const body of this.game.solarSystem.bodies.values()) {
                const dist = Vec2.distance(worldPos, body.position);
                if (dist < body.baseRadius * 1.5 || dist < 1000 / this.game.camera.zoom) {
                    this.game.target = body;
                    this.game.updateTargetUI();
                    return;
                }
            }
        }
    }
    
    handleLeftRelease(e) {
        this.selectedNode = null;
    }
    
    isNearOrbitLine(worldPos) {
        const ship = this.game.ship;
        const soi = ship.currentSOI || this.game.sol;
        
        if (ship.isLanded) return false;
        
        const relPos = ship.position.sub(soi.position);
        const elements = OrbitalMechanics.stateToOrbital(relPos, ship.velocity, soi.mu);
        
        // Check if point is near the orbit
        const relWorld = worldPos.sub(soi.position);
        const r = relWorld.length();
        const expectedR = elements.a * (1 - elements.e * elements.e) / 
            (1 + elements.e * Math.cos(relWorld.angle() - elements.omega));
        
        const tolerance = 500 / this.game.camera.zoom;
        return Math.abs(r - expectedR) < tolerance;
    }
    
    createManeuverNode(worldPos) {
        const ship = this.game.ship;
        const soi = ship.currentSOI || this.game.sol;
        
        // Calculate the true anomaly at this position
        const relPos = worldPos.sub(soi.position);
        const angle = relPos.angle();
        
        // Estimate time to reach this point
        const shipRelPos = ship.position.sub(soi.position);
        const elements = OrbitalMechanics.stateToOrbital(shipRelPos, ship.velocity, soi.mu);
        
        // Create node
        const node = new ManeuverNode(worldPos, this.game.gameTime + 1000, new Vec2(0, 0));
        this.game.maneuverNodes.push(node);
        this.selectedNode = node;
        
        this.game.showMessage('Maneuver Node Created');
    }
    
    updateManeuverNode(e) {
        if (!this.selectedNode) return;
        
        const worldPos = this.game.camera.screenToWorld(
            new Vec2(e.clientX, e.clientY),
            this.game.canvas
        );
        
        // Update delta-V based on mouse position relative to node
        const delta = worldPos.sub(this.selectedNode.position);
        this.selectedNode.deltaV = delta.mul(0.01);
        this.selectedNode.prograde = this.selectedNode.deltaV.length();
    }
    
    update(dt) {
        const ship = this.game.ship;
        
        // Update throttle
        if (ship.input.throttleUp) {
            ship.throttle = Math.min(1, ship.throttle + dt);
        }
        if (ship.input.throttleDown) {
            ship.throttle = Math.max(0, ship.throttle - dt);
        }
    }
}

/* ============================================================================
   SECTION 15: UI MANAGER
   ============================================================================ */

class UIManager {
    constructor(game) {
        this.game = game;
        this.wrtMode = 0; // 0: Surface, 1: Orbit, 2: Target
        this.wrtModes = ['Surface', 'Orbit', 'Target'];
        
        this.setupUI();
    }
    
    setupUI() {
        // WRT toggle
        const wrtButton = document.getElementById('wrt-toggle');
        if (wrtButton) {
            wrtButton.addEventListener('click', () => {
                this.wrtMode = (this.wrtMode + 1) % this.wrtModes.length;
                wrtButton.textContent = 'WRT: ' + this.wrtModes[this.wrtMode];
            });
        }
    }
    
    update() {
        const ship = this.game.ship;
        const soi = ship.currentSOI || this.game.sol;
        
        // Calculate values
        const relPos = ship.position.sub(soi.position);
        const altitude = relPos.length() - soi.getMaxTerrainHeight();
        const velocity = this.getDisplayVelocity();
        
        // Orbital elements
        const elements = ship.isLanded ? null : 
            OrbitalMechanics.stateToOrbital(relPos, ship.velocity, soi.mu);
        
        // Update instrument panel
        this.updateElement('altimeter', this.formatDistance(altitude));
        this.updateElement('velocity', this.formatVelocity(velocity.length()));
        
        // Vertical and horizontal velocity
        if (!ship.isLanded) {
            const radialDir = relPos.normalize();
            const verticalVel = velocity.dot(radialDir);
            const horizontalVel = Math.sqrt(velocity.lengthSq() - verticalVel * verticalVel);
            
            this.updateElement('vertical-vel', this.formatVelocity(verticalVel));
            this.updateElement('horizontal-vel', this.formatVelocity(horizontalVel));
        } else {
            this.updateElement('vertical-vel', '0 m/s');
            this.updateElement('horizontal-vel', '0 m/s');
        }
        
        this.updateElement('current-soi', soi.name);
        
        if (elements && elements.a > 0) {
            this.updateElement('apoapsis', this.formatDistance(elements.ap - soi.baseRadius));
            this.updateElement('periapsis', this.formatDistance(elements.pe - soi.baseRadius));
            this.updateElement('eccentricity', elements.e.toFixed(4));
        } else {
            this.updateElement('apoapsis', elements && elements.e >= 1 ? 'ESCAPE' : '--');
            this.updateElement('periapsis', elements ? this.formatDistance(elements.pe - soi.baseRadius) : '--');
            this.updateElement('eccentricity', elements ? elements.e.toFixed(4) : '--');
        }
        
        // Fuel gauge
        const fuelPercent = (ship.fuel / SHIP_CONFIG.maxFuel) * 100;
        const fuelBar = document.getElementById('fuel-bar');
        const fuelText = document.getElementById('fuel-text');
        if (fuelBar) {
            fuelBar.style.width = fuelPercent + '%';
            if (fuelPercent < 5) {
                fuelBar.style.background = '#fff';
            } else if (fuelPercent < 20) {
                fuelBar.style.background = '#aaa';
            } else {
                fuelBar.style.background = 'linear-gradient(90deg, #666, #aaa)';
            }
        }
        if (fuelText) {
            fuelText.textContent = Math.round(ship.fuel) + ' L';
        }
        
        // Thermal gauge
        const thermalBar = document.getElementById('thermal-bar');
        if (thermalBar) {
            const thermalPercent = (ship.heat / SHIP_CONFIG.maxHeat) * 100;
            thermalBar.style.width = thermalPercent + '%';
        }
        
        // Time warp display
        const warpLevel = this.game.warpLevel;
        const warpRate = WARP_LEVELS[warpLevel];
        
        const chevrons = document.getElementById('warp-chevrons');
        const rateDisplay = document.getElementById('warp-rate');
        if (chevrons) {
            if (warpLevel === 0) {
                chevrons.textContent = '▶';
                chevrons.style.color = '#888';
            } else if (warpLevel <= PHYSICS_WARP_MAX) {
                chevrons.textContent = '▶'.repeat(warpLevel + 1);
                chevrons.style.color = '#aaa';
            } else {
                chevrons.textContent = '▶'.repeat(Math.min(5, warpLevel));
                chevrons.style.color = '#fff';
            }
        }
        if (rateDisplay) {
            rateDisplay.textContent = warpRate + 'x';
        }
        
        // Mode indicator
        const modeIndicator = document.getElementById('mode-indicator');
        if (modeIndicator) {
            modeIndicator.textContent = this.game.mode.toUpperCase();
        }
        
        // Planned mode UI
        const plannedUI = document.getElementById('planned-ui');
        if (plannedUI) {
            plannedUI.style.display = this.game.mode === 'planned' ? 'block' : 'none';
        }
        
        // Landing indicator
        this.updateLandingIndicator();
        
        // Target panel
        this.updateTargetPanel();
        
        // Burn efficiency (Oberth effect)
        this.updateBurnEfficiency();
        
        // Planned mode specific UI
        this.updatePlannedModeUI();
        
        // Apply UI vibration during thrust
        if (ship.throttle > 0.5 && ship.fuel > 0 && !ship.isLanded) {
            this.applyUIVibration(ship.throttle * 0.5);
        }
    }
    
    getDisplayVelocity() {
        const ship = this.game.ship;
        const soi = ship.currentSOI || this.game.sol;
        
        switch(this.wrtMode) {
            case 0: // Surface
                // Subtract body's rotational velocity at ship's position
                const relPos = ship.position.sub(soi.position);
                const angularVel = 2 * Math.PI / soi.rotationPeriod;
                const surfaceVel = new Vec2(
                    -relPos.y * angularVel,
                    relPos.x * angularVel
                );
                return ship.velocity.sub(soi.velocity).sub(surfaceVel);
                
            case 1: // Orbit
                return ship.velocity.sub(soi.velocity);
                
            case 2: // Target
                if (this.game.target) {
                    return ship.velocity.sub(this.game.target.velocity);
                }
                return ship.velocity;
                
            default:
                return ship.velocity;
        }
    }
    
    updateLandingIndicator() {
        const ship = this.game.ship;
        const soi = ship.currentSOI;
        const indicator = document.getElementById('landing-indicator');
        
        if (!indicator) return;
        
        if (!soi || soi.type === 'star') {
            indicator.style.display = 'none';
            return;
        }
        
        const relPos = ship.position.sub(soi.position);
        const altitude = relPos.length() - soi.getMaxTerrainHeight();
        
        // Show indicator when close to surface
        if (altitude < 500 && !ship.isLanded) {
            indicator.style.display = 'block';
            
            const relVel = ship.velocity.sub(soi.velocity);
            const speed = relVel.length();
            
            // Calculate alignment
            const surfaceNormal = soi.getSurfaceNormal(relPos.angle());
            const shipUp = Vec2.fromAngle(ship.angle - Math.PI/2);
            const alignment = Math.abs(shipUp.dot(surfaceNormal));
            const alignAngle = Math.acos(Math.min(1, alignment)) * 180 / Math.PI;
            
            const velDisplay = document.getElementById('landing-vel');
            const angleDisplay = document.getElementById('landing-angle');
            const statusDisplay = document.getElementById('landing-status');
            
            if (velDisplay) velDisplay.textContent = 'V: ' + speed.toFixed(1) + ' m/s';
            if (angleDisplay) angleDisplay.textContent = 'A: ' + alignAngle.toFixed(1) + '°';
            
            const isSafe = speed < SHIP_CONFIG.maxImpactVelocity && alignAngle < 15;
            
            if (statusDisplay) {
                statusDisplay.textContent = isSafe ? 'LANDING SAFE' : 'DANGER';
                statusDisplay.className = isSafe ? 'landing-safe' : 'landing-danger';
            }
        } else {
            indicator.style.display = 'none';
        }
    }
    
    updateTargetPanel() {
        const panel = document.getElementById('target-panel');
        if (!panel) return;
        
        if (!this.game.target) {
            panel.style.display = 'none';
            return;
        }
        
        panel.style.display = 'block';
        
        const ship = this.game.ship;
        const target = this.game.target;
        
        const distance = Vec2.distance(ship.position, target.position);
        const relVel = ship.velocity.sub(target.velocity);
        
        // Calculate phase angle
        const shipAngle = ship.position.sub(this.game.sol.position).angle();
        const targetAngle = target.position.sub(this.game.sol.position).angle();
        let phaseAngle = (targetAngle - shipAngle) * 180 / Math.PI;
        while (phaseAngle < -180) phaseAngle += 360;
        while (phaseAngle > 180) phaseAngle -= 360;
        
        this.updateElement('target-name', target.name);
        this.updateElement('target-distance', this.formatDistance(distance));
        this.updateElement('target-relvel', this.formatVelocity(relVel.length()));
        this.updateElement('phase-angle', phaseAngle.toFixed(1) + '°');
    }
    
    updateBurnEfficiency() {
        const panel = document.getElementById('burn-efficiency');
        const glow = document.getElementById('efficiency-glow');
        
        if (!panel || !glow) return;
        
        const ship = this.game.ship;
        
        if (ship.throttle > 0 && ship.fuel > 0 && !ship.isLanded) {
            panel.style.display = 'block';
            
            // Calculate Oberth effect efficiency
            const soi = ship.currentSOI || this.game.sol;
            const altitude = Vec2.distance(ship.position, soi.position) - soi.baseRadius;
            const efficiency = Math.max(0, 1 - altitude / (soi.soiRadius || soi.baseRadius * 10));
            
            const brightness = 50 + efficiency * 205;
            glow.style.background = `radial-gradient(circle, rgb(${brightness}, ${brightness}, ${brightness}) 0%, #444 100%)`;
        } else {
            panel.style.display = 'none';
        }
    }
    
    updatePlannedModeUI() {
        if (this.game.mode !== 'planned') return;
        
        const ship = this.game.ship;
        
        // Delta-V budget
        const dvBudget = ship.calculateDeltaV();
        this.updateElement('dv-budget', this.formatVelocity(dvBudget));
        
        // Hohmann transfer calculations
        if (this.game.target && this.game.target.parent) {
            const soi = ship.currentSOI || this.game.sol;
            
            // Only calculate if both ship and target orbit same body
            if (soi === this.game.target.parent || soi.parent === this.game.target.parent) {
                const shipDist = Vec2.distance(ship.position, soi.position);
                const targetDist = this.game.target.semiMajorAxis;
                
                const transfer = OrbitalMechanics.hohmannTransfer(shipDist, targetDist, soi.mu);
                
                this.updateElement('hohmann-dv', this.formatVelocity(transfer.totalDv));
                
                // Calculate phase angle
                const shipAngle = ship.position.sub(soi.position).angle();
                const targetAngle = this.game.target.position.sub(soi.position).angle();
                let phaseDiff = (targetAngle - shipAngle) * 180 / Math.PI;
                while (phaseDiff < -180) phaseDiff += 360;
                while (phaseDiff > 180) phaseDiff -= 360;
                
                const optimalPhase = OrbitalMechanics.calculatePhaseAngle(shipDist, targetDist, soi.mu) * 180 / Math.PI;
                const phaseDelta = phaseDiff - optimalPhase;
                
                this.updateElement('hohmann-phase', phaseDelta.toFixed(1) + '°');
            } else {
                this.updateElement('hohmann-dv', 'N/A');
                this.updateElement('hohmann-phase', 'N/A');
            }
        } else {
            this.updateElement('hohmann-dv', '--');
            this.updateElement('hohmann-phase', '--');
        }
    }
    
    applyUIVibration(intensity) {
        const panel = document.getElementById('instrument-panel');
        if (panel) {
            const offsetX = (Math.random() - 0.5) * intensity * 2;
            const offsetY = (Math.random() - 0.5) * intensity * 2;
            panel.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
        }
    }
    
    updateElement(id, value) {
        const el = document.getElementById(id);
        if (el) el.textContent = value;
    }
    
    formatDistance(meters) {
        if (!isFinite(meters)) return '∞';
        
        const abs = Math.abs(meters);
        if (abs >= 1e9) return (meters / 1e9).toFixed(2) + ' Gm';
        if (abs >= 1e6) return (meters / 1e6).toFixed(2) + ' Mm';
        if (abs >= 1e3) return (meters / 1e3).toFixed(2) + ' km';
        return meters.toFixed(1) + ' m';
    }
    
    formatVelocity(mps) {
        if (!isFinite(mps)) return '∞';
        
        const abs = Math.abs(mps);
        if (abs >= 1e3) return (mps / 1e3).toFixed(2) + ' km/s';
        return mps.toFixed(1) + ' m/s';
    }
}

/* ============================================================================
   SECTION 16: SAVE/LOAD SYSTEM
   ============================================================================ */

class SaveSystem {
    constructor(game) {
        this.game = game;
        this.autoSaveInterval = 60000; // 60 seconds
        this.lastSave = 0;
    }
    
    save() {
        const data = {
            version: 1,
            uSeed: this.game.universalSeed,
            gameTime: this.game.gameTime,
            player: {
                pos: { x: this.game.ship.position.x, y: this.game.ship.position.y },
                vel: { x: this.game.ship.velocity.x, y: this.game.ship.velocity.y },
                angle: this.game.ship.angle,
                fuel: this.game.ship.fuel,
                soi: this.game.ship.currentSOI ? this.game.ship.currentSOI.id : null,
                landed: this.game.ship.isLanded,
                landedOn: this.game.ship.landedOn ? this.game.ship.landedOn.id : null,
                landedAngle: this.game.ship.landedAngle
            },
            flags: this.game.flags.map(f => ({
                bodyId: f.bodyId,
                angle: f.angle,
                label: f.label
            })),
            crashes: this.game.crashSites
        };
        
        try {
            localStorage.setItem('orbitalSim_save', JSON.stringify(data));
            console.log('Game saved');
            return true;
        } catch (e) {
            console.error('Save failed:', e);
            return false;
        }
    }
    
    load() {
        try {
            const json = localStorage.getItem('orbitalSim_save');
            if (!json) return false;
            
            const data = JSON.parse(json);
            
            // Restore ship state
            this.game.ship.position = new Vec2(data.player.pos.x, data.player.pos.y);
            this.game.ship.velocity = new Vec2(data.player.vel.x, data.player.vel.y);
            this.game.ship.prevPosition = this.game.ship.position.clone();
            this.game.ship.angle = data.player.angle;
            this.game.ship.fuel = data.player.fuel;
            
            if (data.player.soi) {
                this.game.ship.currentSOI = this.game.solarSystem.bodies.get(data.player.soi);
            }
            
            this.game.ship.isLanded = data.player.landed;
            if (data.player.landedOn) {
                this.game.ship.landedOn = this.game.solarSystem.bodies.get(data.player.landedOn);
                this.game.ship.landedAngle = data.player.landedAngle;
            }
            
            // Restore flags
            this.game.flags = data.flags.map(f => new Flag(f.bodyId, f.angle, f.label));
            
            // Restore crash sites
            this.game.crashSites = data.crashes || [];
            
            this.game.gameTime = data.gameTime;
            
            console.log('Game loaded');
            return true;
        } catch (e) {
            console.error('Load failed:', e);
            return false;
        }
    }
    
    autoSave() {
        const now = Date.now();
        if (now - this.lastSave >= this.autoSaveInterval) {
            this.save();
            this.lastSave = now;
        }
    }
    
    clearSave() {
        localStorage.removeItem('orbitalSim_save');
    }
}

/* ============================================================================
   SECTION 17: MAIN GAME CLASS
   ============================================================================ */

class Game {
    constructor(canvas, seed = 'XJ-992-K') {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.universalSeed = seed;
        
        // Core systems
        this.solarSystem = new SolarSystemGenerator(seed);
        this.sol = this.solarSystem.generate();
        this.ship = new Ship();
        this.camera = new Camera();
        this.physics = new PhysicsEngine(this);
        this.renderer = new Renderer(canvas, this);
        this.input = new InputHandler(this);
        this.ui = new UIManager(this);
        this.saveSystem = new SaveSystem(this);
        
        // Game state
        this.mode = 'manual'; // 'manual' or 'planned'
        this.warpLevel = 0;
        this.gameTime = 0;
        this.realTime = 0;
        this.paused = false;
        
        // World offset for floating origin
        this.worldOffset = new Vec2(0, 0);
        
        // Flags and markers
        this.flags = [];
        this.maneuverNodes = [];
        this.crashSites = [];
        
        // Target
        this.target = null;
        
        // Message display
        this.messageTimeout = null;
        
        // Initialize
        this.init();
    }
    
    init() {
        // Resize canvas
        this.resizeCanvas();
        window.addEventListener('resize', () => this.resizeCanvas());
        
        // Try to load saved game
        if (!this.saveSystem.load()) {
            // Start new game
            this.spawnShip();
        }
        
        // Initial camera setup
        this.camera.focusOn(this.ship.position);
        this.camera.setZoom(0.1);
        
        // Update system name
        document.getElementById('system-name').textContent = 'SOL SYSTEM';
    }
    
    resizeCanvas() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
    }
    
    spawnShip() {
        // Find first planet
        const planet = Array.from(this.solarSystem.bodies.values()).find(b => b.type === 'planet');
        
        if (planet) {
            // Place ship in low orbit around the first planet
            const orbitRadius = planet.baseRadius + 500;
            const orbitVel = Math.sqrt(planet.mu / orbitRadius);
            
            // Update planet position first
            planet.update(0, this.sol.position);
            
            this.ship.position = planet.position.add(new Vec2(orbitRadius, 0));
            this.ship.velocity = planet.velocity.add(new Vec2(0, orbitVel));
            this.ship.prevPosition = this.ship.position.clone();
            this.ship.currentSOI = planet;
            this.ship.fuel = SHIP_CONFIG.maxFuel;
            
            this.showMessage('Welcome to ' + planet.name + ' orbit');
        } else {
            // Fallback: orbit Sol
            const orbitRadius = 20000;
            const orbitVel = Math.sqrt(this.sol.mu / orbitRadius);
            
            this.ship.position = new Vec2(orbitRadius, 0);
            this.ship.velocity = new Vec2(0, orbitVel);
            this.ship.prevPosition = this.ship.position.clone();
        }
    }
    
    resetShip() {
        this.ship.fuel = SHIP_CONFIG.maxFuel;
        this.ship.heat = 0;
        this.ship.engineDamage = 0;
        this.ship.structuralStrain = 0;
        this.spawnShip();
        this.showMessage('Ship Reset');
    }
    
    update(dt) {
        if (this.paused) return;
        
        const warpFactor = WARP_LEVELS[this.warpLevel];
        const simDt = dt * warpFactor;
        
        // Update input
        this.input.update(dt);
        
        // Update celestial bodies
        this.sol.update(simDt);
        this.solarSystem.updateAsteroids(simDt, this.sol.position, this.sol.mu);
        
        // Update ship physics
        this.physics.update(dt);
        
        // Update camera
        this.camera.update(dt, this.ship, this.mode);
        
        // Update game time
        this.gameTime += simDt;
        this.realTime += dt;
        
        // Auto-save
        this.saveSystem.autoSave();
        
        // Update UI
        this.ui.update();
        
        // Check maneuver nodes for execution
        this.checkManeuverNodes();
    }
    
    render() {
        this.renderer.render();
    }
    
    toggleMode() {
        if (this.mode === 'manual') {
            this.mode = 'planned';
            this.camera.setZoom(this.camera.zoom * 0.1);
        } else {
            this.mode = 'manual';
            this.camera.focusOn(this.ship.position);
        }
        this.showMessage(this.mode.toUpperCase() + ' MODE');
    }
    
    increaseWarp() {
        if (this.warpLevel < WARP_LEVELS.length - 1) {
            // Check safety conditions
            if (!this.canIncreaseWarp()) {
                this.showMessage('Cannot increase warp - unsafe conditions');
                return;
            }
            
            this.warpLevel++;
            this.showMessage('Warp: ' + WARP_LEVELS[this.warpLevel] + 'x');
        }
    }
    
    decreaseWarp() {
        if (this.warpLevel > 0) {
            this.warpLevel--;
            this.showMessage('Warp: ' + WARP_LEVELS[this.warpLevel] + 'x');
        }
    }
    
    canIncreaseWarp() {
        const ship = this.ship;
        
        // Can't warp while thrusting at high warp
        if (ship.throttle > 0 && this.warpLevel >= PHYSICS_WARP_MAX) {
            return false;
        }
        
        // Can't warp while landed
        if (ship.isLanded) {
            return false;
        }
        
        // Check for low altitude
        const soi = ship.currentSOI || this.sol;
        if (soi.type !== 'star') {
            const altitude = Vec2.distance(ship.position, soi.position) - soi.getMaxTerrainHeight();
            if (altitude < 1000 && this.warpLevel >= 4) {
                return false;
            }
        }
        
        return true;
    }
    
    cycleTarget() {
        const bodies = Array.from(this.solarSystem.bodies.values());
        
        if (!this.target) {
            this.target = bodies[0];
        } else {
            const idx = bodies.indexOf(this.target);
            this.target = bodies[(idx + 1) % bodies.length];
        }
        
        this.showMessage('Target: ' + this.target.name);
        this.updateTargetUI();
    }
    
    updateTargetUI() {
        // UI manager handles this
    }
    
    plantFlag() {
        if (!this.ship.isLanded || !this.ship.landedOn) {
            this.showMessage('Must be landed to plant flag');
            return;
        }
        
        const label = 'Flag ' + (this.flags.length + 1);
        const flag = new Flag(this.ship.landedOn.id, this.ship.landedAngle, label);
        this.flags.push(flag);
        
        this.showMessage('Flag planted: ' + label);
        this.saveSystem.save();
    }
    
    checkManeuverNodes() {
        // Auto-execute maneuver nodes in planned mode
        if (this.mode !== 'planned') return;
        
        for (const node of this.maneuverNodes) {
            if (node.executed) continue;
            
            const timeToBurn = node.time - this.gameTime;
            
            // Update UI
            const burnDisplay = document.getElementById('time-to-burn');
            const dvDisplay = document.getElementById('node-dv');
            
            if (burnDisplay) {
                if (timeToBurn > 0) {
                    const mins = Math.floor(timeToBurn / 60);
                    const secs = Math.floor(timeToBurn % 60);
                    burnDisplay.textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
                } else {
                    burnDisplay.textContent = 'BURN!';
                }
            }
            
            if (dvDisplay) {
                dvDisplay.textContent = node.getTotalDeltaV().toFixed(1) + ' m/s';
            }
            
            // Execute burn
            if (timeToBurn <= 0 && !node.executed) {
                this.executeBurn(node);
            }
        }
    }
    
    executeBurn(node) {
        const dv = node.deltaV;
        this.ship.velocity = this.ship.velocity.add(dv);
        node.executed = true;
        
        // Remove executed node
        const idx = this.maneuverNodes.indexOf(node);
        if (idx > -1) {
            this.maneuverNodes.splice(idx, 1);
        }
        
        this.showMessage('Burn Complete: ' + dv.length().toFixed(1) + ' m/s');
    }
    
    triggerCrash(reason) {
        // Record crash site
        this.crashSites.push({
            position: this.ship.position.clone(),
            time: this.gameTime,
            soi: this.ship.currentSOI ? this.ship.currentSOI.id : null
        });
        
        // Screen shake
        this.camera.shake(30);
        
        // Reset ship
        this.ship.fuel = Math.max(100, this.ship.fuel * 0.5);
        this.spawnShip();
        
        this.showMessage('CRASH: ' + reason);
    }
    
    showMessage(text) {
        const display = document.getElementById('message-display');
        if (display) {
            display.textContent = text;
            display.style.opacity = '1';
            
            if (this.messageTimeout) {
                clearTimeout(this.messageTimeout);
            }
            
            this.messageTimeout = setTimeout(() => {
                display.style.opacity = '0';
            }, 3000);
        }
    }
    
    gameLoop(timestamp) {
        // Calculate delta time
        const dt = Math.min(0.1, (timestamp - this.lastTimestamp) / 1000);
        this.lastTimestamp = timestamp;
        
        // Update and render
        this.update(dt);
        this.render();
        
        // Request next frame
        requestAnimationFrame((t) => this.gameLoop(t));
    }
    
    start() {
        this.lastTimestamp = performance.now();
        this.gameLoop(this.lastTimestamp);
    }
}

/* ============================================================================
   SECTION 18: QUADTREE SPATIAL PARTITIONING
   For efficient collision detection and gravity calculations
   ============================================================================ */

class QuadTree {
    constructor(bounds, maxObjects = 10, maxLevels = 5, level = 0) {
        this.bounds = bounds; // {x, y, width, height}
        this.maxObjects = maxObjects;
        this.maxLevels = maxLevels;
        this.level = level;
        this.objects = [];
        this.nodes = [];
    }
    
    clear() {
        this.objects = [];
        for (const node of this.nodes) {
            node.clear();
        }
        this.nodes = [];
    }
    
    split() {
        const subWidth = this.bounds.width / 2;
        const subHeight = this.bounds.height / 2;
        const x = this.bounds.x;
        const y = this.bounds.y;
        
        this.nodes[0] = new QuadTree(
            { x: x + subWidth, y: y, width: subWidth, height: subHeight },
            this.maxObjects, this.maxLevels, this.level + 1
        );
        this.nodes[1] = new QuadTree(
            { x: x, y: y, width: subWidth, height: subHeight },
            this.maxObjects, this.maxLevels, this.level + 1
        );
        this.nodes[2] = new QuadTree(
            { x: x, y: y + subHeight, width: subWidth, height: subHeight },
            this.maxObjects, this.maxLevels, this.level + 1
        );
        this.nodes[3] = new QuadTree(
            { x: x + subWidth, y: y + subHeight, width: subWidth, height: subHeight },
            this.maxObjects, this.maxLevels, this.level + 1
        );
    }
    
    getIndex(obj) {
        const midX = this.bounds.x + this.bounds.width / 2;
        const midY = this.bounds.y + this.bounds.height / 2;
        
        const topQuadrant = obj.y < midY;
        const bottomQuadrant = obj.y >= midY;
        
        if (obj.x < midX) {
            if (topQuadrant) return 1;
            if (bottomQuadrant) return 2;
        } else {
            if (topQuadrant) return 0;
            if (bottomQuadrant) return 3;
        }
        
        return -1;
    }
    
    insert(obj) {
        if (this.nodes.length > 0) {
            const index = this.getIndex(obj);
            if (index !== -1) {
                this.nodes[index].insert(obj);
                return;
            }
        }
        
        this.objects.push(obj);
        
        if (this.objects.length > this.maxObjects && this.level < this.maxLevels) {
            if (this.nodes.length === 0) {
                this.split();
            }
            
            let i = 0;
            while (i < this.objects.length) {
                const index = this.getIndex(this.objects[i]);
                if (index !== -1) {
                    this.nodes[index].insert(this.objects.splice(i, 1)[0]);
                } else {
                    i++;
                }
            }
        }
    }
    
    retrieve(obj, result = []) {
        const index = this.getIndex(obj);
        
        if (index !== -1 && this.nodes.length > 0) {
            this.nodes[index].retrieve(obj, result);
        }
        
        result.push(...this.objects);
        return result;
    }
    
    queryRange(range, result = []) {
        if (!this.intersects(range)) {
            return result;
        }
        
        for (const obj of this.objects) {
            if (this.pointInRange(obj, range)) {
                result.push(obj);
            }
        }
        
        for (const node of this.nodes) {
            node.queryRange(range, result);
        }
        
        return result;
    }
    
    intersects(range) {
        return !(range.x > this.bounds.x + this.bounds.width ||
                 range.x + range.width < this.bounds.x ||
                 range.y > this.bounds.y + this.bounds.height ||
                 range.y + range.height < this.bounds.y);
    }
    
    pointInRange(point, range) {
        return point.x >= range.x && point.x <= range.x + range.width &&
               point.y >= range.y && point.y <= range.y + range.height;
    }
}

/* ============================================================================
   SECTION 19: PARTICLE SYSTEM
   For explosions, thrust effects, and debris
   ============================================================================ */

class ParticleSystem {
    constructor() {
        this.particles = [];
        this.maxParticles = 500;
    }
    
    emit(config) {
        const {
            position,
            velocity = new Vec2(0, 0),
            count = 10,
            spread = Math.PI * 2,
            speed = 100,
            speedVariation = 0.5,
            lifetime = 1,
            lifetimeVariation = 0.3,
            size = 3,
            sizeVariation = 0.5,
            color = '#ffffff',
            fadeOut = true,
            shrink = true,
            gravity = null,
            type = 'circle' // 'circle', 'line', 'triangle'
        } = config;
        
        for (let i = 0; i < count && this.particles.length < this.maxParticles; i++) {
            const angle = (Math.random() - 0.5) * spread;
            const particleSpeed = speed * (1 + (Math.random() - 0.5) * speedVariation);
            const particleVel = velocity.add(Vec2.fromAngle(angle, particleSpeed));
            const particleLifetime = lifetime * (1 + (Math.random() - 0.5) * lifetimeVariation);
            const particleSize = size * (1 + (Math.random() - 0.5) * sizeVariation);
            
            this.particles.push({
                position: position.clone(),
                velocity: particleVel,
                lifetime: particleLifetime,
                maxLifetime: particleLifetime,
                size: particleSize,
                maxSize: particleSize,
                color: color,
                fadeOut: fadeOut,
                shrink: shrink,
                gravity: gravity,
                type: type,
                rotation: Math.random() * Math.PI * 2,
                rotationSpeed: (Math.random() - 0.5) * 5
            });
        }
    }
    
    emitExplosion(position, velocity, intensity = 1) {
        // Main explosion particles
        this.emit({
            position,
            velocity: velocity.mul(0.3),
            count: Math.floor(30 * intensity),
            spread: Math.PI * 2,
            speed: 200 * intensity,
            lifetime: 1.5,
            size: 5,
            color: '#ffffff',
            type: 'line'
        });
        
        // Debris
        this.emit({
            position,
            velocity: velocity.mul(0.5),
            count: Math.floor(15 * intensity),
            spread: Math.PI * 2,
            speed: 100 * intensity,
            lifetime: 3,
            size: 4,
            color: '#888888',
            type: 'triangle'
        });
        
        // Sparks
        this.emit({
            position,
            count: Math.floor(50 * intensity),
            spread: Math.PI * 2,
            speed: 300 * intensity,
            lifetime: 0.5,
            size: 2,
            color: '#ffffff',
            type: 'circle'
        });
    }
    
    emitThrust(position, direction, throttle) {
        const baseVel = Vec2.fromAngle(direction + Math.PI, 50);
        
        this.emit({
            position,
            velocity: baseVel,
            count: Math.floor(3 * throttle),
            spread: 0.3,
            speed: 100 + 100 * throttle,
            lifetime: 0.3,
            size: 3 * throttle,
            color: '#cccccc',
            type: 'triangle'
        });
    }
    
    emitRCS(position, direction) {
        const baseVel = Vec2.fromAngle(direction, 30);
        
        this.emit({
            position,
            velocity: baseVel,
            count: 2,
            spread: 0.5,
            speed: 50,
            lifetime: 0.2,
            size: 2,
            color: '#aaaaaa',
            type: 'circle'
        });
    }
    
    update(dt) {
        for (let i = this.particles.length - 1; i >= 0; i--) {
            const p = this.particles[i];
            
            // Update lifetime
            p.lifetime -= dt;
            if (p.lifetime <= 0) {
                this.particles.splice(i, 1);
                continue;
            }
            
            // Apply gravity
            if (p.gravity) {
                p.velocity = p.velocity.add(p.gravity.mul(dt));
            }
            
            // Update position
            p.position = p.position.add(p.velocity.mul(dt));
            
            // Update size
            if (p.shrink) {
                p.size = p.maxSize * (p.lifetime / p.maxLifetime);
            }
            
            // Update rotation
            p.rotation += p.rotationSpeed * dt;
        }
    }
    
    render(ctx, camera, canvas) {
        for (const p of this.particles) {
            const screenPos = camera.worldToScreen(p.position, canvas);
            const alpha = p.fadeOut ? p.lifetime / p.maxLifetime : 1;
            
            ctx.save();
            ctx.translate(screenPos.x, screenPos.y);
            ctx.rotate(p.rotation);
            ctx.globalAlpha = alpha;
            ctx.fillStyle = p.color;
            ctx.strokeStyle = p.color;
            
            const size = Math.max(1, p.size * camera.zoom);
            
            switch (p.type) {
                case 'circle':
                    ctx.beginPath();
                    ctx.arc(0, 0, size, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                    
                case 'line':
                    const lineLength = size * 3;
                    ctx.lineWidth = Math.max(1, size / 2);
                    ctx.beginPath();
                    ctx.moveTo(-lineLength / 2, 0);
                    ctx.lineTo(lineLength / 2, 0);
                    ctx.stroke();
                    break;
                    
                case 'triangle':
                    ctx.beginPath();
                    ctx.moveTo(0, -size);
                    ctx.lineTo(-size * 0.7, size * 0.5);
                    ctx.lineTo(size * 0.7, size * 0.5);
                    ctx.closePath();
                    ctx.fill();
                    break;
            }
            
            ctx.restore();
        }
    }
}

/* ============================================================================
   SECTION 20: SURVEY SYSTEM
   Mini-game for terrain analysis when landed
   ============================================================================ */

class SurveySystem {
    constructor(game) {
        this.game = game;
        this.active = false;
        this.progress = 0;
        this.targetFrequency = 0;
        this.currentFrequency = 0;
        this.surveyedBodies = new Set();
        this.wavePhase = 0;
    }
    
    startSurvey() {
        if (!this.game.ship.isLanded || !this.game.ship.landedOn) {
            this.game.showMessage('Must be landed to survey');
            return;
        }
        
        const body = this.game.ship.landedOn;
        
        if (this.surveyedBodies.has(body.id)) {
            this.game.showMessage(body.name + ' already surveyed');
            return;
        }
        
        this.active = true;
        this.progress = 0;
        this.targetFrequency = 0.5 + Math.random() * 2;
        this.currentFrequency = 1;
        
        this.game.showMessage('Survey started - match the frequency');
    }
    
    update(dt) {
        if (!this.active) return;
        
        this.wavePhase += dt * 5;
        
        // Check if player is adjusting frequency (use Q/E keys)
        if (this.game.ship.input.rotateLeft) {
            this.currentFrequency = Math.max(0.1, this.currentFrequency - dt);
        }
        if (this.game.ship.input.rotateRight) {
            this.currentFrequency = Math.min(3, this.currentFrequency + dt);
        }
        
        // Check match
        const diff = Math.abs(this.currentFrequency - this.targetFrequency);
        if (diff < 0.1) {
            this.progress += dt * (1 - diff * 10);
            
            if (this.progress >= 1) {
                this.completeSurvey();
            }
        } else {
            this.progress = Math.max(0, this.progress - dt * 0.5);
        }
    }
    
    completeSurvey() {
        this.active = false;
        const body = this.game.ship.landedOn;
        this.surveyedBodies.add(body.id);
        this.game.showMessage('Survey complete: ' + body.name + ' mapped!');
    }
    
    cancel() {
        this.active = false;
        this.progress = 0;
    }
    
    render(ctx, canvas) {
        if (!this.active) return;
        
        const width = 300;
        const height = 150;
        const x = (canvas.width - width) / 2;
        const y = (canvas.height - height) / 2;
        
        // Background
        ctx.fillStyle = 'rgba(20, 20, 20, 0.9)';
        ctx.fillRect(x, y, width, height);
        ctx.strokeStyle = '#555';
        ctx.strokeRect(x, y, width, height);
        
        // Title
        ctx.fillStyle = '#fff';
        ctx.font = '14px monospace';
        ctx.textAlign = 'center';
        ctx.fillText('TERRAIN SURVEY', x + width / 2, y + 20);
        
        // Target wave
        ctx.strokeStyle = '#555';
        ctx.lineWidth = 1;
        ctx.beginPath();
        for (let i = 0; i < width - 40; i++) {
            const waveY = Math.sin(i * 0.05 * this.targetFrequency) * 20;
            if (i === 0) {
                ctx.moveTo(x + 20 + i, y + 60 + waveY);
            } else {
                ctx.lineTo(x + 20 + i, y + 60 + waveY);
            }
        }
        ctx.stroke();
        
        // Current wave
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.beginPath();
        for (let i = 0; i < width - 40; i++) {
            const waveY = Math.sin((i * 0.05 * this.currentFrequency) + this.wavePhase) * 20;
            if (i === 0) {
                ctx.moveTo(x + 20 + i, y + 60 + waveY);
            } else {
                ctx.lineTo(x + 20 + i, y + 60 + waveY);
            }
        }
        ctx.stroke();
        
        // Progress bar
        ctx.fillStyle = '#333';
        ctx.fillRect(x + 20, y + 100, width - 40, 20);
        ctx.fillStyle = '#888';
        ctx.fillRect(x + 20, y + 100, (width - 40) * this.progress, 20);
        
        // Instructions
        ctx.fillStyle = '#666';
        ctx.font = '10px monospace';
        ctx.fillText('Use Q/E to adjust frequency', x + width / 2, y + 140);
    }
}

/* ============================================================================
   SECTION 21: WARP-TO-POINT SYSTEM
   ============================================================================ */

class WarpToPoint {
    constructor(game) {
        this.game = game;
        this.active = false;
        this.targetTime = 0;
        this.startTime = 0;
    }
    
    warpTo(targetTime) {
        if (targetTime <= this.game.gameTime) {
            this.game.showMessage('Cannot warp to past');
            return;
        }
        
        this.active = true;
        this.targetTime = targetTime;
        this.startTime = this.game.gameTime;
        
        // Set initial high warp
        this.game.warpLevel = WARP_LEVELS.length - 1;
    }
    
    warpToPeriapsis() {
        const ship = this.game.ship;
        const soi = ship.currentSOI || this.game.sol;
        
        if (ship.isLanded) return;
        
        const relPos = ship.position.sub(soi.position);
        const elements = OrbitalMechanics.stateToOrbital(relPos, ship.velocity, soi.mu);
        
        if (elements.e >= 1) {
            this.game.showMessage('No periapsis on escape trajectory');
            return;
        }
        
        // Calculate time to periapsis
        const n = Math.sqrt(soi.mu / (elements.a * elements.a * elements.a));
        const E = OrbitalMechanics.trueToEccentric(elements.nu, elements.e);
        const M = OrbitalMechanics.eccentricToMean(E, elements.e);
        const timeToP = (2 * Math.PI - M) / n;
        
        this.warpTo(this.game.gameTime + timeToP);
        this.game.showMessage('Warping to periapsis');
    }
    
    warpToApoapsis() {
        const ship = this.game.ship;
        const soi = ship.currentSOI || this.game.sol;
        
        if (ship.isLanded) return;
        
        const relPos = ship.position.sub(soi.position);
        const elements = OrbitalMechanics.stateToOrbital(relPos, ship.velocity, soi.mu);
        
        if (elements.e >= 1) {
            this.game.showMessage('No apoapsis on escape trajectory');
            return;
        }
        
        // Calculate time to apoapsis
        const n = Math.sqrt(soi.mu / (elements.a * elements.a * elements.a));
        const E = OrbitalMechanics.trueToEccentric(elements.nu, elements.e);
        const M = OrbitalMechanics.eccentricToMean(E, elements.e);
        const timeToA = (Math.PI - M) / n;
        if (timeToA < 0) {
            this.warpTo(this.game.gameTime + timeToA + elements.period);
        } else {
            this.warpTo(this.game.gameTime + timeToA);
        }
        this.game.showMessage('Warping to apoapsis');
    }
    
    update(dt) {
        if (!this.active) return;
        
        const remaining = this.targetTime - this.game.gameTime;
        const total = this.targetTime - this.startTime;
        
        if (remaining <= 0) {
            this.active = false;
            this.game.warpLevel = 0;
            this.game.showMessage('Warp complete');
            return;
        }
        
        // Slow down as we approach target
        const progress = 1 - (remaining / total);
        
        if (remaining < 10) {
            this.game.warpLevel = 0;
        } else if (remaining < 100) {
            this.game.warpLevel = Math.min(this.game.warpLevel, 2);
        } else if (remaining < 1000) {
            this.game.warpLevel = Math.min(this.game.warpLevel, 5);
        }
    }
    
    cancel() {
        this.active = false;
        this.game.warpLevel = 0;
    }
}

/* ============================================================================
   SECTION 22: GRAVITY ASSIST CALCULATOR
   ============================================================================ */

class GravityAssistCalculator {
    constructor(game) {
        this.game = game;
    }
    
    calculateAssist(shipVelocity, bodyVelocity, bodyMu, periapsis) {
        // Relative velocity at infinity
        const vInf = shipVelocity.sub(bodyVelocity);
        const vInfMag = vInf.length();
        
        // Calculate deflection angle
        const e = 1 + (periapsis * vInfMag * vInfMag) / bodyMu;
        const delta = 2 * Math.asin(1 / e);
        
        // Velocity change magnitude
        const dv = 2 * vInfMag * Math.sin(delta / 2);
        
        return {
            deflectionAngle: delta,
            deltaV: dv,
            eccentricity: e
        };
    }
    
    predictAssist(ship, body) {
        // Check if trajectory passes through body's SOI
        const soi = ship.currentSOI || this.game.sol;
        const relPos = ship.position.sub(soi.position);
        const elements = OrbitalMechanics.stateToOrbital(relPos, ship.velocity, soi.mu);
        
        // Find closest approach to body
        let minDist = Infinity;
        let closestPos = null;
        let closestTime = 0;
        
        const numSamples = 100;
        const totalTime = elements.period || 100000;
        
        for (let i = 0; i < numSamples; i++) {
            const t = (i / numSamples) * totalTime;
            const result = OrbitalMechanics.propagateOrbit(elements, soi.mu, t);
            const pos = soi.position.add(result.position);
            
            // Also propagate body
            if (body.parent) {
                const bodyElements = {
                    a: body.semiMajorAxis,
                    e: body.eccentricity,
                    omega: body.argumentOfPeriapsis,
                    nu: body.trueAnomaly
                };
                const bodyResult = OrbitalMechanics.propagateOrbit(bodyElements, body.parent.mu, t);
                const bodyPos = body.parent.position.add(bodyResult.position);
                
                const dist = Vec2.distance(pos, bodyPos);
                if (dist < minDist) {
                    minDist = dist;
                    closestPos = pos;
                    closestTime = t;
                }
            }
        }
        
        if (minDist < body.soiRadius) {
            return {
                willAssist: true,
                closestApproach: minDist,
                timeToApproach: closestTime,
                position: closestPos
            };
        }
        
        return { willAssist: false };
    }
}

/* ============================================================================
   SECTION 23: ENHANCED RENDERER METHODS
   ============================================================================ */

// Add these methods to Renderer class
Renderer.prototype.drawWreckage = function() {
    const ctx = this.ctx;
    const camera = this.game.camera;
    
    for (const crash of this.game.crashSites) {
        const screenPos = camera.worldToScreen(crash.position, this.canvas);
        
        // Draw wreckage icon
        ctx.save();
        ctx.translate(screenPos.x, screenPos.y);
        
        ctx.strokeStyle = '#666';
        ctx.lineWidth = 1;
        
        // Broken ship outline
        ctx.beginPath();
        ctx.moveTo(-5, 5);
        ctx.lineTo(0, -5);
        ctx.lineTo(5, 5);
        ctx.stroke();
        
        // X mark
        ctx.strokeStyle = '#444';
        ctx.beginPath();
        ctx.moveTo(-8, -8);
        ctx.lineTo(8, 8);
        ctx.moveTo(8, -8);
        ctx.lineTo(-8, 8);
        ctx.stroke();
        
        ctx.restore();
    }
};

Renderer.prototype.drawMinimap = function() {
    const container = document.getElementById('minimap-container');
    const minimapCanvas = document.getElementById('minimap');
    
    if (!container || !minimapCanvas) return;
    
    // Only show in planned mode
    if (this.game.mode !== 'planned') {
        container.style.display = 'none';
        return;
    }
    
    container.style.display = 'block';
    
    const mctx = minimapCanvas.getContext('2d');
    const size = 150;
    const cx = size / 2;
    const cy = size / 2;
    
    // Clear
    mctx.fillStyle = '#0a0a0a';
    mctx.fillRect(0, 0, size, size);
    
    // Calculate scale to fit entire system
    let maxDist = 0;
    for (const body of this.game.solarSystem.bodies.values()) {
        if (body.type !== 'star') {
            const dist = body.semiMajorAxis;
            if (dist > maxDist) maxDist = dist;
        }
    }
    
    const scale = (size * 0.45) / maxDist;
    
    // Draw Sol
    mctx.fillStyle = '#ffffff';
    mctx.beginPath();
    mctx.arc(cx, cy, 3, 0, Math.PI * 2);
    mctx.fill();
    
    // Draw planet orbits and positions
    for (const body of this.game.solarSystem.bodies.values()) {
        if (body.type !== 'planet') continue;
        
        const orbitRadius = body.semiMajorAxis * scale;
        
        // Orbit
        mctx.strokeStyle = 'rgba(80, 80, 80, 0.5)';
        mctx.lineWidth = 1;
        mctx.beginPath();
        mctx.arc(cx, cy, orbitRadius, 0, Math.PI * 2);
        mctx.stroke();
        
        // Planet position
        const relPos = body.position.sub(this.game.sol.position);
        const x = cx + relPos.x * scale;
        const y = cy - relPos.y * scale;
        
        mctx.fillStyle = '#888888';
        mctx.beginPath();
        mctx.arc(x, y, 2, 0, Math.PI * 2);
        mctx.fill();
    }
    
    // Draw ship position
    const shipRelPos = this.game.ship.position.sub(this.game.sol.position);
    const shipX = cx + shipRelPos.x * scale;
    const shipY = cy - shipRelPos.y * scale;
    
    // Clamp to minimap bounds
    const clampedX = Math.max(5, Math.min(size - 5, shipX));
    const clampedY = Math.max(5, Math.min(size - 5, shipY));
    
    mctx.fillStyle = '#ffffff';
    mctx.beginPath();
    mctx.moveTo(clampedX, clampedY - 4);
    mctx.lineTo(clampedX - 3, clampedY + 2);
    mctx.lineTo(clampedX + 3, clampedY + 2);
    mctx.closePath();
    mctx.fill();
    
    // Draw target if exists
    if (this.game.target && this.game.target.type !== 'star') {
        const targetRelPos = this.game.target.position.sub(this.game.sol.position);
        const targetX = cx + targetRelPos.x * scale;
        const targetY = cy - targetRelPos.y * scale;
        
        mctx.strokeStyle = '#aaaaaa';
        mctx.lineWidth = 1;
        mctx.strokeRect(targetX - 4, targetY - 4, 8, 8);
    }
    
    // Camera view frustum indicator
    const camRange = (this.game.canvas.width / 2) / this.game.camera.zoom;
    const frustumSize = camRange * scale * 2;
    if (frustumSize < size * 0.8) {
        const camX = cx + (this.game.camera.position.x - this.game.sol.position.x) * scale;
        const camY = cy - (this.game.camera.position.y - this.game.sol.position.y) * scale;
        
        mctx.strokeStyle = 'rgba(150, 150, 150, 0.3)';
        mctx.lineWidth = 1;
        mctx.strokeRect(
            camX - frustumSize / 2,
            camY - frustumSize / 2,
            frustumSize,
            frustumSize
        );
    }
};

Renderer.prototype.drawGravityAssistPreview = function() {
    const ctx = this.ctx;
    const camera = this.game.camera;
    const ship = this.game.ship;
    
    if (ship.isLanded) return;
    
    const calculator = new GravityAssistCalculator(this.game);
    
    for (const body of this.game.solarSystem.bodies.values()) {
        if (body.type === 'star') continue;
        
        const assist = calculator.predictAssist(ship, body);
        
        if (assist.willAssist && assist.position) {
            const screenPos = camera.worldToScreen(assist.position, this.canvas);
            
            // Draw assist marker
            ctx.save();
            ctx.translate(screenPos.x, screenPos.y);
            
            ctx.strokeStyle = '#88ff88';
            ctx.lineWidth = 2;
            
            // Curved arrow indicating deflection
            ctx.beginPath();
            ctx.arc(0, 0, 15, 0, Math.PI);
            ctx.stroke();
            
            // Arrow head
            ctx.beginPath();
            ctx.moveTo(-15, 0);
            ctx.lineTo(-10, -5);
            ctx.lineTo(-10, 5);
            ctx.closePath();
            ctx.fill();
            
            ctx.restore();
        }
    }
};

/* ============================================================================
   SECTION 24: INITIALIZATION
   ============================================================================ */

// Start the game when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    const canvas = document.getElementById('gameCanvas');
    
    // Create game instance with default seed
    const game = new Game(canvas, 'XJ-992-K');
    
    // Add additional systems
    game.particles = new ParticleSystem();
    game.survey = new SurveySystem(game);
    game.warpToPoint = new WarpToPoint(game);
    game.gravityAssist = new GravityAssistCalculator(game);
    game.quadtree = new QuadTree({
        x: -1000000,
        y: -1000000,
        width: 2000000,
        height: 2000000
    });
    
    // Extend update to include new systems
    const originalUpdate = game.update.bind(game);
    game.update = function(dt) {
        originalUpdate(dt);
        this.particles.update(dt);
        this.survey.update(dt);
        this.warpToPoint.update(dt);
        
        // Update quadtree with asteroids
        this.quadtree.clear();
        for (const asteroid of this.solarSystem.asteroids) {
            this.quadtree.insert({
                x: asteroid.position.x,
                y: asteroid.position.y,
                object: asteroid
            });
        }
    };
    
    // Extend render to include new systems
    const originalRender = game.render.bind(game);
    game.render = function() {
        originalRender();
        this.particles.render(this.ctx, this.camera, this.canvas);
        this.renderer.drawWreckage();
        this.renderer.drawMinimap();
        this.renderer.drawGravityAssistPreview();
        this.survey.render(this.ctx, this.canvas);
        
        // Update delta-V readout
        const dvReadout = document.getElementById('dv-readout');
        const currentDv = document.getElementById('current-dv');
        if (dvReadout && currentDv) {
            if (this.ship.throttle > 0 && !this.ship.isLanded) {
                dvReadout.style.display = 'block';
                currentDv.textContent = this.ship.calculateDeltaV().toFixed(1) + ' m/s remaining';
            } else {
                dvReadout.style.display = 'none';
            }
        }
    };
    
    // Extend triggerCrash to add explosion
    const originalCrash = game.triggerCrash.bind(game);
    game.triggerCrash = function(reason) {
        this.particles.emitExplosion(this.ship.position, this.ship.velocity, 2);
        originalCrash(reason);
    };
    
    // Add keyboard shortcuts for new features
    window.addEventListener('keydown', (e) => {
        switch(e.key.toLowerCase()) {
            case 'p':
                game.warpToPoint.warpToPeriapsis();
                break;
            case 'o':
                game.warpToPoint.warpToApoapsis();
                break;
            case 'v':
                if (game.ship.isLanded) {
                    game.survey.startSurvey();
                }
                break;
            case 'escape':
                game.survey.cancel();
                game.warpToPoint.cancel();
                break;
        }
    });
    
    // Make game globally accessible for debugging
    window.game = game;
    
    // Start game loop
    game.start();
    
    console.log('Orbital Mechanics Simulator initialized');
    console.log('Seed:', game.universalSeed);
    console.log('Bodies:', game.solarSystem.bodies.size);
    console.log('Asteroids:', game.solarSystem.asteroids.length);
    console.log('');
    console.log('Additional Controls:');
    console.log('  P - Warp to Periapsis');
    console.log('  O - Warp to Apoapsis');
    console.log('  V - Start Survey (when landed)');
    console.log('  ESC - Cancel warp/survey');
});
    </script>
</body>
</html>
